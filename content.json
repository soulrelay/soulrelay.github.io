{"meta":{"title":"SuS's World","subtitle":"Much to Live For","description":"手掌一散，流落走多少时光","author":"SuS","url":"http://yoursite.com"},"pages":[{"title":"欢迎来到我的世界","date":"2016-03-30T06:11:08.000Z","updated":"2017-08-06T02:49:39.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"用心观察 我的CSDN博客地址：http://blog.csdn.net/s003603u 我的GitHub地址：https://github.com/soulrelay 我的简书地址：http://www.jianshu.com/u/514ca03bbc17 我的掘金地址：https://juejin.im/user/56f3d9d1816dfa00522b8f20 我的个人站点： http://sushuai.tech/ 秋景，俄罗斯的郊外 七彩之巅，从37000英尺高空俯瞰大海 谁把春天打翻了？ 生命必须有裂缝，阳关才能照进来 你见过这样喝水的鸟吗？一种名为“伯劳”的凶猛鸟类，有“空中屠夫”之称，却生性怕水。 金秋，美景如画 日本冲绳岛 阳光，森林 好一个大月亮 弹好的棉花，飘到天上，成了云；未弹的，掉在地上，成了石头。太阳出来了，把它们染成了斑斓。 每一个成功者都是一位苦行僧。只有他们自己才知道，通往成功的道路上，到底有多少寂寞与不解。 360度的星空，后期合成 不管是不是世界末日，都要和爱的人在一起。 不是巧合，胜似巧合。 城市里的一天 春天的承诺 给你一点阳光，你就灿烂吧 华丽的夜 宁静的夜，宁静的蓝 漂浮的天堂 如痴如画，暴风雨 山谷夜，月亮眼 天堂的阶梯，向日葵原的神奇夕阳 相依相偎，不离不弃 想起梵高的星空大爱这流水 一池嫣红 一只学过物理的松鼠 因为只有在年轻时灿烂燃烧过，年老后才会变成恬静有气质 鹰饮映鹰影 渔舟唱晚，不知乘月几人归 致命邂逅 坐井观天"},{"title":"categories","date":"2016-03-30T04:56:55.000Z","updated":"2016-03-30T04:57:56.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-03-30T04:51:34.000Z","updated":"2016-03-30T04:52:40.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android关于ThreadLocal的思考和总结","slug":"Android关于ThreadLocal的思考和总结","date":"2017-08-09T09:15:00.000Z","updated":"2017-08-09T09:39:05.000Z","comments":true,"path":"2017/08/09/Android关于ThreadLocal的思考和总结/","link":"","permalink":"http://yoursite.com/2017/08/09/Android关于ThreadLocal的思考和总结/","excerpt":"","text":"前言Handler机制引出ThreadLocal 关于ThreadLocal的分析，首先得从Android的消息机制谈起，可能我们最先想到的就是Android消息机制的上层接口Handler 为了避免ANR，我们会通常把耗时操作放在子线程里面去执行，因为子线程不能更新UI，所以当子线程需要更新UI的时候就需要借助到Android的消息机制，也就是Handler机制了 关于Handler的原理，不是本文剖析的重点，这里仅给出一些相关结论，同时引出今天的主角ThreadLocal Handler的处理过程运行在创建Handler的线程里 一个Looper对应一个MessageQueue 一个线程对应一个Looper 一个Looper可以对应多个Handler 线程是默认没有Looper的，线程需要通过Looper.prepare()、绑定Handler到Looper对象、Looper.loop()来建立消息循环 主线程（UI线程），也就是ActivityThread，在被创建的时候就会初始化Looper，所以主线程中可以默认使用Handler 可以通过Looper的quitSafely()或者quit()方法终结消息循环，quitSafely相比于quit方法安全之处在于清空消息之前会派发所有的非延迟消息。 不确定当前线程时，更新UI时尽量调用post方法 如何保证一个线程对应一个Looper，同时各个线程之间的Looper互不干扰就引出了接下来要讨论的ThreadLocal1234567public final class Looper &#123; private static final String TAG = \"Looper\"; // sThreadLocal.get() will return null unless you've called prepare(). static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); ....//省略 &#125; 分析案例展示及运行结果这里先给出ThreadLocal和InheritableThreadLocal的简单实用demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ThreadLocalTest &#123; static final String CONSTANT_01 = \"CONSTANT_01\"; static final String CONSTANT_02 = \"CONSTANT_02\"; public static void main(String[] args) throws InterruptedException &#123; ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;String&gt;(); threadLocal.set(CONSTANT_01); InheritableThreadLocal&lt;String&gt; inheritableThreadLocal = new InheritableThreadLocal&lt;String&gt;(); inheritableThreadLocal.set(CONSTANT_01); Thread thread_1 = new TestThread(threadLocal, inheritableThreadLocal); thread_1.setName(\"thread_01\"); thread_1.start(); thread_1.join(); System.out.println(\" \" + Thread.currentThread().getName() + \" ******************************************\"); System.out.println(\" \" + Thread.currentThread().getName() + \" \\tThreadLocal: \" + threadLocal.get()); System.out.println(\" \" + Thread.currentThread().getName() + \" \\tInheritableThreadLocal: \" + inheritableThreadLocal.get()); System.out.println(\" \" + Thread.currentThread().getName() + \" ******************************************\"); &#125;&#125;class TestThread extends Thread &#123; ThreadLocal&lt;String&gt; threadLocal; InheritableThreadLocal&lt;String&gt; inheritableThreadLocal; public TestThread(ThreadLocal&lt;String&gt; threadLocal, InheritableThreadLocal&lt;String&gt; inheritableThreadLocal) &#123; super(); this.threadLocal = threadLocal; this.inheritableThreadLocal = inheritableThreadLocal; &#125; public void run() &#123; System.out.println(Thread.currentThread().getName() + \"******************************************\"); System.out.println(Thread.currentThread().getName() + \"\\tThreadLocal: \" + threadLocal.get()); System.out.println(Thread.currentThread().getName() + \"\\tInheritableThreadLocal: \" + inheritableThreadLocal.get()); System.out.println(Thread.currentThread().getName() + \"******************************************\\n\"); threadLocal.set(ThreadLocalTest.CONSTANT_02); inheritableThreadLocal.set(ThreadLocalTest.CONSTANT_02); System.out.println(Thread.currentThread().getName() + \"*************(Reset Value)****************\"); System.out.println(Thread.currentThread().getName() + \"\\tThreadLocal: \" + threadLocal.get()); System.out.println(Thread.currentThread().getName() + \"\\tInheritableThreadLocal: \" + inheritableThreadLocal.get()); System.out.println(Thread.currentThread().getName() + \"*************(Reset Value)****************\\n\"); &#125;&#125; 运行结果： 1234567891011121314thread_01******************************************thread_01 ThreadLocal: nullthread_01 InheritableThreadLocal: CONSTANT_01thread_01******************************************thread_01*************(Reset Value)****************thread_01 ThreadLocal: CONSTANT_02thread_01 InheritableThreadLocal: CONSTANT_02thread_01*************(Reset Value)**************** main ****************************************** main ThreadLocal: CONSTANT_01 main InheritableThreadLocal: CONSTANT_01 main ****************************************** 如果这个时候你对运行结果有疑问 或者说 「我擦」怎么又突然冒出来一个InheritableThreadLocal，那么请继续往下看 ThreadLocal类结构预览当然，我们肯定要先从ThreadLocal开始说起： 先从大体上看一下，可以发现，Java和Android中ThreadLocal的类结构（包括部分细节）还是有一些区别的，不过Android中的实现方式越来越贴近Java版 第一张图为jdk1.8.0_131中ThreadLocal的类结构： 第二张图为android-25中ThreadLocal的类结构： ThreadLocal探秘这里主要以Android-25（Android7.1.1）的源码为基础进行分析，其实几乎和Java版本的源码一致 首先澄清一下对ThreadLocal的错误认知： ThreadLocal为解决多线程程序的并发问题提供了一种新的思路 ThreadLocal的目的是为了解决多线程访问资源时的共享问题 为什么这么说那？我们看看Android源码中是如何介绍ThreadLocal的： This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID). 描述的大致意思是这样：ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。 可以这么总结：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 有时候大家会拿同步机制（如synchronized）和ThreadLocal做对比，怎么说才能不引起误解那？可以这么理解：对于多线程资源共享的问题，前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。但是ThreadLocal却并不是为了解决并发或者多线程资源共享而设计的 所以ThreadLocal既不是为了解决共享多线程的访问问题，更不是为了解决线程同步问题，ThreadLocal的设计初衷就是为了提供线程内部的局部变量，方便在本线程内随时随地的读取，并且与其他线程隔离。 ThreadLocal的应用场景： 当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候如：属性动画为每个线程设置AnimationHandler、Android的Handler消息机制中通过ThreadLocal实现Looper在线程中的存取、EventBus获取当前线程的PostingThreadState对象或者即将被分发的事件队列或者当前线程是否正在进行事件分发的布尔值 复杂逻辑下的对象传递使用参数传递的话：当函数调用栈更深时，设计会很糟糕，为每一个线程定义一个静态变量监听器，如果是多线程的话，一个线程就需要定义一个静态变量，无法扩展，这时候使用ThreadLocal就可以解决问题。 ThreadLocal源码解读构造函数：12public ThreadLocal() &#123;&#125;创建一个线程的本地变量initialValue函数：123protected T initialValue() &#123; return null;&#125;该函数在调用get函数的时候会第一次调用，但是如果一开始就调用了set函数，则该函数不会被调用。通常该函数只会被调用一次，除非手动调用了remove函数之后又调用get函数，这种情况下，get函数中还是会调用initialValue函数。该函数是protected类型的，很显然是建议在子类重载该函数的，所以通常该函数都会以匿名内部类的形式被重载，以指定初始值，比如12345678public class TestThreadLocal &#123; private static final ThreadLocal&lt;Integer&gt; value = new ThreadLocal&lt;Integer&gt;() &#123; @Override protected Integer initialValue() &#123; return Integer.valueOf(1); &#125; &#125;;&#125;get函数： 该函数用来获取与当前线程关联的ThreadLocal的值,如果当前线程没有该ThreadLocal的值，则调用initialValue函数获取初始值返回123456789101112131415161718192021222324252627282930313233 public T get() &#123; //1、首先获取当前线程 Thread t = Thread.currentThread(); //2、根据当前线程获取一个map ThreadLocalMap map = getMap(t); //3、如果获取的map不为空，则在map中以ThreadLocal的引用作为key来在Map中获取对应的Entry e，否则转到5 if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); //4、如果e不为null，则返回e.value，否则转到5 if (e != null) return (T)e.value; &#125; //5、map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的map return setInitialValue(); &#125; ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; &#125;void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; 值得注意的是，上面getMap方法中获取的threadLocals即是Thread中的一个成员变量123456789 public class Thread implements Runnable &#123; ...//省略 /* ThreadLocal values pertaining to this thread. This map is maintained by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; /* * InheritableThreadLocal values pertaining to this thread. This map is maintained by the InheritableThreadLocal class.*/ ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; ...//省略&#125; 这里的inheritableThreadLocals会在下文分析InheritableThreadLocal涉及到 set函数： set函数用来设置当前线程的该ThreadLocal的值,设置当前线程的ThreadLocal的值为value123456789101112public void set(T value) &#123; //1、首先获取当前线程 Thread t = Thread.currentThread(); //2、根据当前线程获取一个map ThreadLocalMap map = getMap(t); if (map != null) //3、map不为空，则把键值对保存到map中 map.set(this, value); //4、如果map为空（第一次调用的时候map值为null），则去创建一个ThreadLocalMap对象并赋值给map，并把键值对保存到map中。 else createMap(t, value);&#125; remove函数： remove函数用来将当前线程的ThreadLocal绑定的值删除,在某些情况下需要手动调用该函数，防止内存泄露。12345public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); &#125; ThreadLocalMap 可以看成一个HashMap，但是它本身具体的实现却与java.util.Map沾不上一点关系。只是内部的实现跟HashMap类似（通过哈希表的方式存储）。1234567891011static class ThreadLocalMap &#123; static class Entry extend WeakReference&lt;ThreadLocal&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) &#123; super(k); value = v; &#125; &#125; ...//省略 &#125; 大致类结构如下图所示： ThreadLocalMap中定义了Entry数组实例table，用于存储Entry。相当于使用一个数组维护一张哈希表，负载因子是最大容量的2/31private Entry[] table; 关于ThreadLocalMap重要函数的分析会结合下一节ThreadLocal内存泄漏的问题一并讨论 PS：Android早期版本，这部分的数据结构是通过Values实现的，Values中也有一个table的成员变量，table是一个Object数组，也是以类似map的方式来存储的。偶数单元存储的是key，key的下一个单元存储的是对应的value，所以每存储一个元素，需要两个单元，所以容量一定是2的倍数。这里的key存储的也是ThreadLocal实例的弱引用 ThreadLocal内存泄漏的问题ThreadLocal里面使用了一个存在弱引用的map,当释放掉ThreadLocal的强引用以后,map里面的value却没有被回收.而这块value永远不会被访问到了. 所以存在着内存泄露. 最好的做法是将调用ThreadLocal的remove方法. 在ThreadLocal的生命周期中,都存在这些引用. 看下图(来源参考): 实线代表强引用,虚线代表弱引用. 每个thread中都存在一个map, map的类型是ThreadLocal.ThreadLocalMap. Map中的key为一个ThreadLocal实例. 这个Map的确使用了弱引用,不过弱引用只是针对key. 每个key都弱引用指向ThreadLocal. 当把ThreadLocal实例置为null以后,没有任何强引用指向ThreadLocal实例,所以ThreadLocal将会被gc回收. 但是,我们的value却不能回收,因为存在一条从current thread连接过来的强引用. 只有当前thread结束以后, current thread就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收. 所以得出一个结论就是只要这个线程对象被gc回收，就不会出现内存泄露，但在ThreadLocal设为null和线程结束这段时间不会被回收的，就发生了我们认为的内存泄露。其实这是一个对概念理解的不一致，也没什么好争论的。最要命的是线程对象不被回收的情况，这就发生了真正意义上的内存泄露。比如使用线程池的时候，线程结束是不会销毁的，会再次使用的。就可能出现内存泄露。 为了最小化减少内存泄露的可能性和影响，(设计中加上了一些防护措施)在ThreadLocal的get,set的时候都会清除线程Map里所有key为null的value。所以最怕的情况就是，threadLocal对象设null了，开始发生“内存泄露”，然后使用线程池，这个线程结束，线程放回线程池中不销毁，这个线程一直不被使用，或者分配使用了又不再调用get,set方法，那么这个期间就会发生真正的内存泄露。 getEntry函数： 首先从ThreadLocal的直接索引位置获取Entry e，如果e不为null并且key相同则返回e；如果e为null或者key不一致则通过getEntryAfterMiss向下一个位置查询12345678private Entry getEntry(ThreadLocal key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e); &#125; getEntryAfterMiss函数： 这个过程中遇到的key为null的Entry都会被擦除（Entry内的value也就没有强引用链，自然会被回收）12345678910111213141516171819private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal k = e.get(); if (k == key) //命中 return e; if (k == null) //如果key值为null，则擦除该位置的Entry expungeStaleEntry(i); else i = nextIndex(i, len); //继续向下一个位置查询 e = tab[i]; &#125; return null; &#125; set函数：set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露123456789101112131415161718192021222324252627private void set(ThreadLocal key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125;小结： 虽然源码中对内存泄漏做了很好的防护作用，但是很多情况下还是需要手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。 所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。 InheritableThreadLocal与ThreadLocal的区别InheritableThreadLocal比ThreadLocal多一个特性，继承性，可以从父线程中得到初始值 首先浏览下 InheritableThreadLocal 类中有什么东西： 1234567891011public class InheritableThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; &#123; protected T childValue(T parentValue) &#123; return parentValue; &#125; ThreadLocalMap getMap(Thread t) &#123; return t.inheritableThreadLocals; &#125; void createMap(Thread t, T firstValue) &#123; t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue); &#125;&#125; 其实就是重写了3个方法 InheritableThreadLocal的get()方法会调用getMap(t),而这时返回的是inheritableThreadLocals(Thread的一个成员变量) 父线程往子线程中传递值是在Thread thread = new Thread()的时候，然后调用线程内部的init方法进行处理，最终就是不断的把当前线程的inheritableThreadLocals值复制到我们新创建的线程中的inheritableThreadLocals 中 主要面对的是线程中再创建线程的场景，类似开篇举的例子，而对于子线程之间的传递或者线程池中得到父线程的值则不可行（这部分没有深入研究） 总结 现在回过头来分析开篇的例子： 第一次打印：子线程中的ThreadLocal没有赋值，所以为null，而子线程中的InheritableThreadLocal却可以获取到父线程中的值CONSTANT_01 第二次打印：子线程ThreadLocal和InheritableThreadLocal同时重新赋值CONSTANT_02，所以打印出的结果都为CONSTANT_02 第三次打印：回到主线程，主线程和子线程都是维护自己的副本，所以子线程赋值CONSTANT_02并不会对主线程有任何影响，所以主线程打印出的结果依旧都是CONSTANT_01 参考https://www.zhihu.com/question/23089780https://github.com/pzxwhc/MineKnowContainer/issues/12https://github.com/pzxwhc/MineKnowContainer/issues/20http://blog.csdn.net/singwhatiwanna/article/details/48350919http://www.cnblogs.com/onlywujun/p/3524675.html 其它 我的CSDN博客地址：http://blog.csdn.net/s003603u 我的GitHub地址：https://github.com/soulrelay 我的简书地址：http://www.jianshu.com/u/514ca03bbc17 我的掘金地址：https://juejin.im/user/56f3d9d1816dfa00522b8f20 我的个人站点： http://sushuai.tech/","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"http://yoursite.com/tags/ThreadLocal/"}]},{"title":"发布Library到JCenter，步步为营","slug":"发布Library到JCenter，步步为营","date":"2017-08-03T04:00:00.000Z","updated":"2017-08-04T10:25:25.000Z","comments":true,"path":"2017/08/03/发布Library到JCenter，步步为营/","link":"","permalink":"http://yoursite.com/2017/08/03/发布Library到JCenter，步步为营/","excerpt":"","text":"前言将自己写的库上传到Jcenter或者Maven提供给自己或者别人使用，在构建项目的时候只要写上一行如下类似的引用代码即可引用自己的库1compile 'com.sus.library:imagelib:1.0.0' 看到这篇文章的同学可能之前已经踩了不少坑，希望下面的介绍可以帮你解惑如果有什么问题欢迎提出！趁热乎哈！ 下面将逐步介绍如何将Library发布到JCenter 具体案例为：ImageLoaderUtil所有下文涉及到的文件和配置都包含在其中，如果你觉得对你有用，麻烦STAR一下 1、进入Bintray官网 这里选择“For an Open Source Account Sign Up Here”,而非“START YOUR FREE TRIAL”，如果选择 “START YOUR FREE TRIAL”，可能会碰到下面的问题 Bintray link to jcenter missing 问题结论就是：”Add To JCenter” is not enabled for Enterprise Trial users. You need to be OSS or Premium organization/user in order to link your packages to JCenter. 2、注册账号填写相关信息，邮箱尽量使用Gmail邮箱地址（国内邮箱有可能无法注册或者注册成功无法收到激活邮件），注册完成之后到你填写的邮箱里面去激活Bintray账号即可举例： First Name : Shuai Last Name : Su Username : su2008shuai Password : xxxxxxxxxxxxxx Emai Address : su2008shuai@gmail.com Select Country : China 3、创建代码仓库 点击上图所示的“Add NewRepository”按钮，添加代码仓库，点击后就会跳转到下图的界面 举例： Name : me Type : Maven 4、获取头像对应的API KEY点击右上角个人头像进入到个人信息主界面，点击Edit按钮即可进入到下图所示的界面。点击“API KEY”，输入Bintray本账号的登陆密码，即可查看到本账号的API KEY 5、Add New Package举例： Name : imagelib License : Apache-2.0 Version control : https://github.com/soulrelay/ImageLoaderUtil 6、Project的build.gradle添加如下信息在Project的build.gradle添加如下信息:1234//用于打包Maven所需文件classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1' //用于上传Maven生成的文件到Bintrayclasspath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6' 我的Project的build.gradle的完整信息：123456789101112131415161718192021222324252627282930313233343536// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123;repositories &#123;jcenter()&#125;dependencies &#123;classpath 'com.android.tools.build:gradle:2.3.0'//用于打包Maven所需文件classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1' //用于上传Maven生成的文件到Bintrayclasspath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6' // NOTE: Do not place your application dependencies here; they belong// in the individual module build.gradle files&#125;&#125;allprojects &#123;repositories &#123;jcenter()maven &#123;name 'glide-snapshot'url 'http://oss.sonatype.org/content/repositories/snapshots'&#125;&#125;tasks.withType(Javadoc) &#123;options.addStringOption('Xdoclint:none', '-quiet')options.addStringOption('encoding', 'UTF-8')&#125;&#125;task clean(type: Delete) &#123;delete rootProject.buildDir&#125; 7、配置并应用bintrayUpload.gradle，配置bintray.properties和project.properties 7.1 在imagelib Module的根目录下创建bintrayUpload.gradle文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125apply plugin: 'com.github.dcendents.android-maven'apply plugin: 'com.jfrog.bintray'//加载属性文件Properties properties = new Properties()File localPropertiesFile = project.file(\"bintray.properties\");if (localPropertiesFile.exists()) &#123;properties.load(localPropertiesFile.newDataInputStream())&#125;File projectPropertiesFile = project.file(\"project.properties\");if (projectPropertiesFile.exists()) &#123;properties.load(projectPropertiesFile.newDataInputStream())&#125;//读取属性def projectRepositoryName = properties.getProperty(\"project.repositoryName\")def projectName = properties.getProperty(\"project.name\")def projectGroupId = properties.getProperty(\"project.groupId\")def projectArtifactId = properties.getProperty(\"project.artifactId\")def projectVersionName = android.defaultConfig.versionNamedef projectPackaging = properties.getProperty(\"project.packaging\")def projectSiteUrl = properties.getProperty(\"project.siteUrl\")def projectGitUrl = properties.getProperty(\"project.gitUrl\")def projectVersionDesc = properties.getProperty(\"project.versiondesc\")def projectVersionVcsTag = properties.getProperty(\"project.versionvcstag\")def developerId = properties.getProperty(\"developer.id\")def developerName = properties.getProperty(\"developer.name\")def developerEmail = properties.getProperty(\"developer.email\")def bintrayUser = properties.getProperty(\"bintray.user\")def bintrayApikey = properties.getProperty(\"bintray.apiKey\")def bintrayOrganizationId = properties.getProperty(\"bintray.organizationId\");def javadocName = properties.getProperty(\"javadoc.name\")group = projectGroupId// 配置生成POM.xml文件的参数install &#123;repositories.mavenInstaller &#123;pom &#123;project &#123;name projectNamegroupId projectGroupIdartifactId projectArtifactIdversion projectVersionNamepackaging projectPackagingurl projectSiteUrllicenses &#123;license &#123;name 'The Apache Software License, Version 2.0'url 'http://www.apache.org/licenses/LICENSE-2.0.txt'&#125;&#125;developers &#123;developer &#123;id developerIdname developerNameemail developerEmail&#125;&#125;scm &#123;connection projectGitUrldeveloperConnection projectGitUrlurl projectSiteUrl&#125;&#125;&#125;&#125;&#125;//生成sources.jartask sourcesJar(type: Jar) &#123;from android.sourceSets.main.java.srcDirsclassifier = 'sources'&#125;task javadoc(type: Javadoc) &#123;source = android.sourceSets.main.java.srcDirsclasspath += project.files(android.getBootClasspath().join(File.pathSeparator))&#125;//生成javadoc.jartask javadocJar(type: Jar, dependsOn: javadoc) &#123;classifier = 'javadoc'from javadoc.destinationDir&#125;artifacts &#123;archives javadocJararchives sourcesJar&#125;//javadoc的配置javadoc &#123;options &#123;encoding \"UTF-8\"charSet 'UTF-8'author trueversion projectVersionNamelinks \"http://docs.oracle.com/javase/7/docs/api\"title javadocName&#125;&#125;bintray &#123;user = bintrayUserkey = bintrayApikeyconfigurations = ['archives']pkg &#123;//userOrg = bintrayOrganizationIdrepo = projectRepositoryNamename = projectNamewebsiteUrl = projectSiteUrlvcsUrl = projectGitUrllicenses = [\"Apache-2.0\"]publish = trueversion &#123;name = projectVersionNamedesc = projectVersionDescvcsTag = projectVersionVcsTag&#125;&#125;&#125; 7.2 在imagelib Module的build.gradle中应用上面创建的bintrayUpload.gradle文件，添加如下代码1apply from: \"bintrayUpload.gradle\" 这里注意会遇到一个奇葩问题： Where:Script ‘/Users/sus/share/ImageLoaderUtil/imagelib/bintrayUpload.gradle’ line: 85*What went wrong:A problem occurred evaluating script.android.compileSdkVersion is missing! 其实就是「 android.compileSdkVersion is missing!」 这个问题很奇葩，需要把apply from: “bintrayUpload.gradle”这句话放在最下面，如下完整文件信息所示，我碰到这个问题的时候是直接把这句话放在apply plugin: ‘com.android.library’的后面了 完整文件信息： 12345678910111213141516171819202122232425262728293031323334apply plugin: 'com.android.library'android &#123;compileSdkVersion 24buildToolsVersion '25.0.0'defaultConfig &#123;minSdkVersion 15targetSdkVersion 25versionCode 1versionName \"1.0.0\"testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"&#125;buildTypes &#123;release &#123;minifyEnabled falseproguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'&#125;&#125;&#125;dependencies &#123;compile fileTree(include: ['*.jar'], dir: 'libs')androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123;exclude group: 'com.android.support', module: 'support-annotations'&#125;)compile 'com.android.support:appcompat-v7:24.2.1'testCompile 'junit:junit:4.12'compile 'com.android.support:support-v4:24.2.1'compile 'com.squareup.okhttp3:okhttp:3.4.2'compile 'com.github.bumptech.glide:glide:3.8.0-SNAPSHOT'compile 'com.github.bumptech.glide:okhttp-integration:1.5.0-SNAPSHOT'&#125;apply from: \"bintrayUpload.gradle\" 7.3 在imagelib Module的根目录下创建7.1要读取的配置文件创建bintray.properties用于配置bintray和开发者信息 1234567891011121314151617#配置bintray账号相关信息#bintray用户名,不是登陆邮箱,是个人中心右上角显示的名字bintray.user=su2008shuai#bintray的ApiKeybintray.apiKey=xxxxxxxxxxxxx#bintray的Organization Id#bintray.organizationId=soulrelay#配置开发者信息#昵称developer.id=sushuai#姓名developer.name=sushuai#邮箱developer.email=su2008shuai@gmail.com 创建project.properties用于配置项目信息 1234567891011121314151617181920#project#仓库名称，就是在bintray官网建立的仓库的名称project.repositoryName=me#项目名称project.name=imagelib#项目组idproject.groupId=com.sus.library#项目id,一般同project.nameproject.artifactId=imagelib#打包类型project.packaging=aar#项目官方网站地址project.siteUrl=https://github.com/soulrelay/ImageLoaderUtil#项目git地址project.gitUrl=https://github.com/soulrelay/ImageLoaderUtil#生成的javadoc名称javadoc.name=imagelibproject.versiondesc = 1.0.0 normalproject.versionvcstag = 1.0.0 tag 7.4 在Terminal窗口下输入如下指令上传到Bintray12gradlew installgradlew bintrayUpload 期间可能会碰到如下问题 -bash: gradlew: command not found 解决方案：gradlew is not in your global path. To execute the ‘clean’ task (or any task for that matter) using the gradle wrapper (gradlew) in your project directory in your terminal, specify the current directory with the ‘./‘: ./gradlew clean Running mac, you also have to do “chmod 755 gradlew” on the file before to make it executable. 归结起来的话： chmod 755 gradlew ./gradlew install ./gradlew bintrayUpload 若出现BUILD SUCCESSFUL则说明成功上传到了Bintray(有时候在执行./gradlew bintrayUpload的时候报错，但这时去bintray官网查看它也上传成功了，可能是缓存的问题，可以Invalidate Caches or clean restart一下试试) 8、添加imagelib Package到JCenter进入到Bintray网站，找到刚才上传的项目，点击右下角的“Add To JCenter”按钮然后填写项目描述点击“Send”提交审核即可（这里可以什么都不干，直接点击Send按钮），如果审核成功，它会给你发送一封站内信（同时你注册的邮箱优也会收到通知，1天之内肯定可以收到通知）通知你。 访问这个链接：https://jcenter.bintray.com/com/sus/library/imagelib/1.0.0/ 9、其它问题和说明 Could not upload to ‘https://api.bintray.com/content/su2008shuai/me/ImageLoaderUtil/1.0/ImageLoaderUtil/imagelib/1.0/imagelib-1.0-javadoc.jar‘: HTTP/1.1 400 Bad Request [message:Failed to resolve package name] Error:Could not find ImageLoaderUtil.jar (com.sus.library:ImageLoaderUtil:1.0.1).Searched in the following locations:https://jcenter.bintray.com/com/sus/library/ImageLoaderUtil/1.0.1/ImageLoaderUtil-1.0.1.jar 类似上面的问题的原因都是配置不对，bintray.properties和project.properties上的配置一定要和bintray线上的配置一致，否则会报各种找不到xx的问题 我的CSDN博客地址：http://blog.csdn.net/s003603u 我的GitHub地址：https://github.com/soulrelay 我的简书地址：http://www.jianshu.com/u/514ca03bbc17","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Jcenter","slug":"Jcenter","permalink":"http://yoursite.com/tags/Jcenter/"}]},{"title":"基于Activity、Fragment的生命周期避免MVP模式内存泄露的问题","slug":"基于Activity、Fragment的生命周期避免MVP模式内存泄露的问题","date":"2017-02-23T03:47:00.000Z","updated":"2017-08-04T10:29:33.000Z","comments":true,"path":"2017/02/23/基于Activity、Fragment的生命周期避免MVP模式内存泄露的问题/","link":"","permalink":"http://yoursite.com/2017/02/23/基于Activity、Fragment的生命周期避免MVP模式内存泄露的问题/","excerpt":"","text":"前言回顾之前对MVP做过相关研究《Android-architecture之MVC、MVP、MVVM、Data-Binding》，也做过简单的分享《Android Architecture（Is Activity God？）》，在《列表全家桶之刷新、加载更多、悬浮、左滑删除》中也提到过希望对MVP相关做进一步的升级，抽取出了BasePresenter、BaseView、MVPBaseActivity、MVPBaseFragment，并通过使用弱引用预防可能发生的内存泄露问题 ，遂抽空着手整理一下 框架模式、设计模式、架构的关系 框架模式通常是对（面向相同行为代码的重用）代码的重用，是大智慧，用来对软件设计进行分工 设计模式通常是对（面向相同结构代码的重用）设计的重用，是小技巧，对具体问题提出解决方案，以提高代码复用率，降低耦合度 架构则介于框架和设计之间 我们所说的MVC、MVP、MVVM是一种框架模式而非设计模式 Android图片加载库的封装实战即是通过设计模式完成对图片加载框架Glide进行封装的案例问题发现MVP有很多优点，例如： 易于维护 易于测试 松耦合 复用性高 健壮稳定 易于扩展 但是，由于Presenter经常性地需要执行一些耗时操作，例如请求网络数据，而Presenter持有了Activity或者Fragment的强引用，如果在请求结束之前Activity或者Fragment被销毁了，那么由于网络请求还没有返回，导致Presenter一直持有Activity或者Fragment的对象，使得Activity或者Fragment对象无法回收，此时就发生了内存泄露 MVP模式内存泄露问题的解决答案就是，通过弱引用和Activity、Fragment的生命周期来解决这个问题，首先建立一个Presenter对象，我们命名为BasePresenter，它是一个泛型类，泛型类型为View角色要实现的接口类型，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Author: SuS * Version V1.0 * Date: 17/02/23 * Description:通过弱引用和Activity以及Fragment的生命周期预防内存泄露的问题 * Modification History: * Date Author Version Description * ----------------------------------------------------------------------------------- * 17/02/23 SuS 1.0 1.0 * Why &amp; What is modified: */public abstract class BasePresenter&lt;V&gt; &#123; protected Reference&lt;V&gt; mViewRef;//View 接口类型的弱引用 public void attachView(V view) &#123; mViewRef = new WeakReference&lt;V&gt;(view); &#125; protected V getView() &#123; return mViewRef.get(); &#125; public boolean isViewAttached() &#123; return mViewRef != null &amp;&amp; mViewRef.get() != null; &#125; public void detachView() &#123; if (mViewRef != null) &#123; mViewRef.clear(); mViewRef = null; &#125; &#125; //每个Presenter都会有初始化的工作，可以在这里统一处理 // 当然也可以不处理，这里只是一个公用的示范方法 public abstract void start(); //这里也可以理解为一个公用的示范方法 public abstract void update();&#125; 除了start和update两个公用的示范方法，BasePresenter还有4个方法，分别与View建立关联、解除关联、判断是否与View建立了关联、获取View。View类型通过BasePresenter的泛型类型传递进来，Presenter对这个View持有弱引用。通常情况下这个View类型应该是实现了某个特定接口的Activity或者Fragment等类型。创建一个MVPBaseActivity基类，通过这个基类的生命周期函数来控制它与Presenter的关系，相关代码如下： 123456789101112131415161718192021222324252627282930 /** * Author: SuS * Version V1.0 * Date: 17/02/23 * Description:MVP Activity基类 * Modification History: * Date Author Version Description * ----------------------------------------------------------------------------------- * 17/02/23 SuS 1.0 1.0 * Why &amp; What is modified: */public abstract class MVPBaseActivity&lt;V,P extends BasePresenter&lt;V&gt;&gt; extends BaseActivity &#123; private static final String TAG = \"MVPBaseActivity\"; protected P mPresenter; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mPresenter = createPresenter();//创建Presenter mPresenter.attachView((V)this); &#125; @Override public void onDestroy() &#123; super.onDestroy(); mPresenter.detachView(); &#125; protected abstract P createPresenter();&#125; MVPBaseActivity含有两个泛型参数，第一个是View接口类型，第二个是Presenter的具体类型，通过泛型参数，使得一些通用的逻辑可以抽象到MVPBaseActivity类中。例如，在MVPBaseActivity的onCreate函数中，会通过createPresenter函数创建一个具体的Presenter，这个Presenter的类型就是BasePresenter类型。构建Presenter之后调用attachView函数与Activity建立关联，而在onDestroy函数中，则会与Activity解除关联，从而避免内存泄露。疑问：如果在onDestroy中解除了对Activity的引用，那么就没有必要再用弱引用了解惑：并不是在任何情况下Activity的onDestroy都会被调用（其它原因导致Activity对象还在被引用，就不会回调onDestroy方法），一旦这种情况发生，弱引用也能够保证不会造成内存泄露。而通过MVPBaseActivity的封装维护Presenter与View关联关系的代码，使得子类可以避免重复的代码。当然我们也可以把同样的思想用到更广阔的范围，例如可以为Fragment或者FragmentActivity建立类似这样的基类 123456789101112131415161718192021222324252627282930 /** * Author: SuS * Version V1.0 * Date: 17/02/23 * Description:MVP Fragment基类 * Modification History: * Date Author Version Description * ----------------------------------------------------------------------------------- * 17/02/23 SuS 1.0 1.0 * Why &amp; What is modified: */public abstract class MVPBaseFragment&lt;V,P extends BasePresenter&lt;V&gt;&gt; extends BaseFragment &#123; private static final String TAG = \"MVPBaseFragment\"; protected P mPresenter; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mPresenter = createPresenter();//创建Presenter mPresenter.attachView((V)this); &#125; @Override public void onDestroy() &#123; super.onDestroy(); mPresenter.detachView(); &#125; protected abstract P createPresenter();&#125; 补充：其实我们在Activity中嵌套Fragment的情况下也可以通过如下方式将Presenter从Activity注入到Fragment 123456public interface BaseView&lt;P&gt; &#123; //这个可以在Activity中包裹Fragment的时候应用，这时候继承MVPBaseActivity //Activity中初始化Presenter的实例 ，然后通过view调用该方法将Presenter塞给Fragment void setPresenter(P presenter);&#125; 定义自己的MVP框架提供一个MVPContract ，封装MVP需要的所有基础接口，View和InteractionListener中使用的泛型为加载的数据类型，假设为MVPItem类型1234567891011121314151617181920212223242526272829303132333435public class MVPContract &#123; public interface Model &#123; //请求数据 void loadContent(boolean isLoadMore, String lastKey); &#125; public interface View&lt;T&gt; &#123; //销毁加载页面 void dismissLoadingViews(); //展示加载页面 void showLoadingViews(); //展示异常页面 void showErrorViews(int errorCode, String msg); //刷新块数据的内容 void refreshContentView(ArrayList&lt;T&gt; contentList); //加载更多块数据的内容 void loadMoreContentView(ArrayList&lt;T&gt; contentList); &#125; public interface Presenter &#123; //下拉刷新请求 void requestRefresh(); //加载更多数据 void requestLoadMore(); &#125; public interface InteractionListener&lt;T&gt; &#123; //请求成功 void onInteractionSuccess(T t); //请求失败 void onInteractionFail(int errorCode, String errorMsg); &#125;&#125; 实现自己的Presenter，命名为MVPPresenter 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class MVPPresenter extends BasePresenter&lt;MVPContract .View&lt;MVPItem&gt;&gt; implements MVPContract .InteractionListener&lt;ArrayList&lt;MVPItem&gt;&gt;,MVPContract .Presenter&#123; private MVPContract .View&lt;MVPItem&gt; mView; private MVPContract .Model mModel; private String param1; private ArrayList&lt;MVPItem&gt; mList; private boolean isLoading = false; private boolean isLoadMore = false; public MVPPresenter (String param, MVPContract .View&lt;MVPItem&gt; view)&#123; this.param= param; this.mView = view; mModel = new MVPModel(param,this); &#125; @Override public void onInteractionSuccess(ArrayList&lt;MVPItem&gt; list) &#123; isLoading = false; if(isLoadMore)&#123; this.mList.addAll(list); mView.loadMoreContentView(list); &#125; else &#123; this.mList = list; mView.refreshContentView(list); &#125; mView.dismissLoadingViews(); &#125; @Override public void onInteractionFail(int errorCode, String errorMsg) &#123; isLoading = false; mView.dismissLoadingViews(); mView.showErrorViews(errorCode, errorMsg); &#125; @Override public synchronized void requestRefresh() &#123; if (isLoading) &#123; return; &#125; isLoading = true; isLoadMore = false; mModel.loadContent(false,null); &#125; @Override public synchronized void requestLoadMore() &#123; if (isLoading) &#123; return; &#125; if (mList == null || mList.size() == 0) &#123; return; &#125; isLoading = true; isLoadMore = true; mModel.loadContent(true,mList.get(mList.size() - 1).getKey()); &#125; @Override public void start() &#123; if (isLoading) &#123; return; &#125; isLoading = true; isLoadMore = false; mView.showLoadingViews(); mModel.loadContent(false,null); &#125; @Override public void update() &#123; &#125;&#125; 实现自己的Model，命名为MVPModel 123456789101112131415161718192021222324public class MVPModel implements MVPContract.Model &#123; private MVPContract.InteractionListener&lt;ArrayList&lt;MVPItem&gt;&gt; mListener; private String param; public MVPModel(String param, MVPContract.InteractionListener&lt;ArrayList&lt;MVPItem&gt;&gt; listener) &#123; this.param = param; this.mListener = listener; &#125; @Override public void loadContent(boolean isLoadMore, String lastKey) &#123; //网络请求 //数据处理 //成功或者失败的回调 //伪代码 if（success）&#123; mListener.onInteractionSuccess(\"结果数据\"); &#125;else&#123; mListener.onInteractionFail(\"错误码\",\"错误信息\"); &#125; &#125;&#125; 例如MVPFragment 继承自MVPBaseFragment的实现如下：此时，Presenter的创建以及与View建立关联等操作都被封装到MVPBaseFragment中，消除了子类重复代码的同时又避免了内存泄露的问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class MVPFragment extends MVPBaseFragment&lt;MVPContract.View&lt;MVPItem&gt;, MVPPresenter&gt; implements MVPContract.View&lt;MVPItem&gt;, MVPListView.IListener&#123; private static final String TAG = MVPFragment.class.getSimpleName(); private String param; public MVPFragment() &#123; // Required empty public constructor &#125; public static MVPFragment newInstance(String param) &#123; MVPFragment fragment = new MVPFragment(); Bundle args = new Bundle(); args.putString(\"param\", param); fragment.setArguments(args); return fragment; &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; if (getArguments() != null) &#123; param = getArguments().getString(\"param\"); &#125; super.onCreate(savedInstanceState); &#125; @Override protected MVPPresenter createPresenter() &#123; return new MVPPresenter(param, this); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflate the layout for this fragment View v = inflater.inflate(R.layout.fragment_mvp, container, false); initView(v); return v; &#125; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); initData(); &#125; private void initView(View v) &#123; &#125; private void initData() &#123; mPresenter.start(); &#125; @Override public void dismissLoadingViews() &#123; &#125; @Override public void showLoadingViews() &#123; &#125; @Override public void showErrorViews(int errorCode, String msg) &#123; &#125; @Override public void refreshContentView(ArrayList&lt;MVPItem&gt; contentList) &#123; &#125; @Override public void loadMoreContentView(ArrayList&lt;MVPItem&gt; contentList) &#123; &#125; @Override public void onRefresh() &#123; mPresenter.requestRefresh(); &#125; @Override public void onLoadMore() &#123; mPresenter.requestLoadMore(); &#125; &#125; 这里的MVPListView.IListener如下：（仅做参考）123456789/** * Implements this interface to get refresh/load more event. */public interface IListener&#123; public void onRefresh(); public void onLoadMore();&#125; 小结 从整体效果来说，MVP是开发过程中非常值得推荐的架构模式，它能够将各组件进行解耦，并且带来良好的可扩展性、可测试性、稳定性、可维护性，同时使得每个类型的职责相对单一、简单，避免了大量的“胖”的程序存在，例如数千行的Activity类。它有效的将业务逻辑、数据处理等工作从Activity等View元素中抽离出来，使得每个类尽可能简单，同时每个模块能够独立进行演化。它的思想也非常好地体现了面向对象的设计原则，即抽象、单一指责、最小化、低耦合。 当然，需要说明的是，你的项目并不一定非要用MVP/MVVM或者别的什么模式，模式都有它们自身应用的范围，利弊并存，但了解是必需的，不然你很难扩展自己的技能范围，高级的开发应该学会判断某个项目是否合适一些现成的模式，合理的使用模式会让你的应用框架更加清晰并且易于维护和扩展。 参考Android源码设计模式解析与实战","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"MVP","slug":"MVP","permalink":"http://yoursite.com/tags/MVP/"},{"name":"内存泄漏","slug":"内存泄漏","permalink":"http://yoursite.com/tags/内存泄漏/"}]},{"title":"Android基于ImageLoaderUtil封装库的图集实现","slug":"Android基于ImageLoaderUtil封装库的图集实现","date":"2017-02-17T04:47:00.000Z","updated":"2017-08-04T10:35:45.000Z","comments":true,"path":"2017/02/17/Android基于ImageLoaderUtil封装库的图集实现/","link":"","permalink":"http://yoursite.com/2017/02/17/Android基于ImageLoaderUtil封装库的图集实现/","excerpt":"","text":"前言之前写了一篇图片加载库的封装案例，其中基于Glide完成了图片加载库ImageLoaderUtil的封装，ImageLoaderUtil提供了诸多图片加载相关的接口： 正常加载图片 针对于GIF图片的特殊加载 加载图片的进度回调 清除缓存 获取缓存大小 图片本地保存 进度回调和本地保存均支持GIF 经过一段时间的检验，ImageLoaderUtil在实际项目中表现良好，并且随着各种问题的暴露、跟进、解决，ImageLoaderUtil也逐渐趋于完善，能够满足项目中大部分关于图片加载的需求，之前的ImageLoaderUtil只是给出了一个很简单的案例来证明这套图片加载库可用，并没有很全面地呈现ImageLoaderUtil真正的价值，因此，我准备基于ImageLoaderUtil来实现一个图集功能，一个大部分APP中都会呈现的一个功能 图集功能简介一般图集的入口是这样的：（不过这不是重点，我们主要实现点击进去的图集详情页） 点击进入是这样的： 不要在意数据的不匹配，数据都是随便搞的，哈哈哈 言归正传！来捋一下一个图集详情页应有的基本功能： 支持图片的手势滑动（ViewPager），多点触控放大缩小（PhotoView） 伴随图片切换的标题简介切换 图集的保存、分享（暂无）、评论（暂无）、收藏（暂无） 当前图集浏览完毕，支持切换到相关的图集推荐（目前很简陋） 图集推荐同时又是一个进入图集详情页的入口 部分功能点分析Gallery中的页面UI结构参考源码，了解更多 通过ImageLoaderUtil提供的loadImageWithProgress实现图片加载的进度回调1234567891011121314151617181920212223private void showImage(final View retryView, ImageItem item, final PhotoView photoView, final TextView progressStr, final View progressLayout) &#123; if (item == null) &#123; return; &#125; String url = item.getImage(); ImageLoaderUtil.getInstance().loadImageWithProgress(url, photoView, new ProgressLoadListener() &#123; @Override public void update(int bytesRead, int contentLength) &#123; progressStr.setText(bytesRead * 100 / contentLength + \"%\"); &#125; @Override public void onException() &#123; retryView.setVisibility(View.VISIBLE); progressLayout.setVisibility(View.GONE); &#125; @Override public void onResourceReady() &#123; progressLayout.setVisibility(View.GONE); &#125; &#125;);&#125; 进度加载效果图如下： 通过ImageLoaderUtil提供的saveImage实现图片加载的本地保存12345678910111213141516171819202122232425private void saveImage() &#123; if (list == null) &#123; ToastUtils.toastCenter(getActivity(), R.string.save_image_fail); return; &#125; final String url = list.get(viewPager.getCurrentItem()).getImage(); ThreadPoolUtils.execute(new Runnable() &#123; @Override public void run() &#123; ImageLoaderUtil.getInstance().saveImage(getActivity(), url, Environment.getExternalStorageDirectory().getAbsolutePath() + \"/gallery\", \"pic\" + System.currentTimeMillis(), new ImageSaveListener() &#123; @Override public void onSaveSuccess() &#123; handler.obtainMessage(MSG_PIC_SAVE_SUCC).sendToTarget(); &#125; @Override public void onSaveFail() &#123; handler.obtainMessage(MSG_PIC_SAVE_FAIL).sendToTarget(); &#125; &#125;); &#125; &#125;); &#125; 效果图如下： Android 六点零 运行时权限处理上面说到图片的保存功能，自然需要获得内存卡的读写权限，在API23+以上（targetSdkVersion设置到23或者以上时），不止要在AndroidManifest.xml里面添加权限12&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; 还得在需要该权限的地方主动调用（详情请参考GalleryFragment，同时需要注意Fragment与Activity在申请运行时权限的不同，Activity中使用ActivityCompat.requestPermissions，而Fragment使用自己本身，如GalleryFragment.this.requestPermissions）否则会报（java.io.FileNotFoundException:open failed: EACCES (Permission denied)） 上图即是在targetSdkVersion设置到23，在6.0系统的手机上运行，弹出授权dialog，只有允许才能保存图片成功，否在会报权限拒绝 参考代码：123456789101112131415161718192021222324252627282930313233343536/** * Checks if the app has permission to write to device storage * &lt;p&gt; * If the app does not has permission then the user will be prompted to * grant permissions * * @param activity */public void verifyStoragePermissions(Activity activity) &#123; // Check if we have write permission int permission = ActivityCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE); if (permission != PackageManager.PERMISSION_GRANTED) &#123; // We don't have permission so prompt the user GalleryFragment.this.requestPermissions(PERMISSIONS_STORAGE, REQUEST_EXTERNAL_STORAGE); &#125; else &#123; saveImage(); &#125;&#125;@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; if (requestCode == REQUEST_EXTERNAL_STORAGE) &#123; if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; saveImage(); &#125; else &#123; // Permission Denied ToastUtils.toastCenter(getActivity(), R.string.permission_denied); &#125; return; &#125; super.onRequestPermissionsResult(requestCode, permissions, grantResults);&#125; ViewPaper嵌套相关处理ViewPaper嵌套使用时，当里面的viewpaper未滑动到最后一个时，外面的viewpaper禁止滑动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MyViewPager extends ViewPager &#123; private OnNeedScrollListener mOnNeedScrollListener; public MyViewPager(Context context) &#123; super(context); &#125; public MyViewPager(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public void setOnNeedScrollListener(OnNeedScrollListener listener)&#123; this.mOnNeedScrollListener = listener; &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; if(mOnNeedScrollListener != null &amp;&amp; !mOnNeedScrollListener.needScroll())&#123; return false; &#125; else &#123; try &#123; return super.onTouchEvent(ev); &#125; catch (IllegalArgumentException ex) &#123; ex.printStackTrace(); return false; &#125; &#125; &#125; @Override public boolean onInterceptTouchEvent(MotionEvent event) &#123; if(mOnNeedScrollListener != null &amp;&amp; !mOnNeedScrollListener.needScroll())&#123; return false; &#125; else &#123; try &#123; return super.onInterceptTouchEvent(event); &#125; catch (IllegalArgumentException ex) &#123; ex.printStackTrace(); return false; &#125; &#125; &#125; public interface OnNeedScrollListener&#123; boolean needScroll(); &#125;&#125; 只有当GalleryFragment中的ViewPager滑动到最后一个，且图集推荐中有内容，才会触发外层ViewPager的滑动12345678910111213141516@Overridepublic boolean needScroll() &#123; if (mCurrFragment instanceof GalleryFragment) &#123; if (!((GalleryFragment) mCurrFragment).isLastItem()) &#123; return false; &#125; else &#123; //当图集滑动到最后一个时，如果图集推荐没有内容，则禁止滑动 GalleryRelatedFragment relatedFragment = (GalleryRelatedFragment) fragments.get(1); if (!relatedFragment.isHasData()) &#123; return false; &#125; &#125; &#125; return true;&#125; 源码传送门github—–&gt;Gallery csdn—–&gt;Gallery","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Glide","slug":"Glide","permalink":"http://yoursite.com/tags/Glide/"},{"name":"图片加载","slug":"图片加载","permalink":"http://yoursite.com/tags/图片加载/"},{"name":"Gallery","slug":"Gallery","permalink":"http://yoursite.com/tags/Gallery/"}]},{"title":"绝对值得一看的Android数据库升级攻略","slug":"绝对值得一看的Android数据库升级攻略","date":"2017-01-03T08:47:00.000Z","updated":"2017-08-04T16:29:06.000Z","comments":true,"path":"2017/01/03/绝对值得一看的Android数据库升级攻略/","link":"","permalink":"http://yoursite.com/2017/01/03/绝对值得一看的Android数据库升级攻略/","excerpt":"","text":"Android数据存储方式 Android提供了五种方式来让用户保存持久化应用程序数据。根据自己的需求来做选择，比如数据是否是应用程序私有的，是否能被其他程序访问，需要多少数据存储空间等，分别是： SharedPreferences存储 文件存储 SQLite数据库存储 ContentProvider存储 网络存储 当存取数据比较复杂时，我们会选择SQLite数据库进行存储，下面我们会介绍一下在使用SQLite时遇到的问题及相应的解决方案 Android数据库升级完整解决方案数据库升级的意义 数据库表的设计往往不是一开始就非常完美，可能在应用版本开发迭代中，如新功能发布，业务逻辑变更，早期的数据库结构无法满足新版本的需求方法 让用户卸载老版本再安装新的程序；缺点：可操作性低，软件卸载会造成老数据的丢失 软件自行更新数据库结构。可取：作为开发者必须妥善处理数据库的升级问题解决方案数据库的升级，无外乎以下几种情况： 增加表 删除表 增加表和删除表问题不大，因为它们都没有涉及到数据的迁移问题，增加表只是在原来的基础上CREATE TABLE，而删除表就是对历史数据不需要了，那只要DROP TABLE即可&gt;* 修改表（修改表字段，删除表字段，增加表字段）①可能一个比较暴力的做法：就是将原来的表删除了然后重新创建新的表，这样就不用考虑其他因素了。这种方法不可取，会造成数据丢失。②明智的做法：表升级，数据也要迁移 首先需要理解SQLiteOpenHelper中的两个重要函数： 123456public abstract class SQLiteOpenHelper &#123; //数据库第一次创建的时候调用 public abstract void onCreate(SQLiteDatabase db); //当数据库版本升级的时候调用 public abstract void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion);&#125; 然后来看看具体如何来修改表定义： SQLite数库对ALTER TABLE命令支持非常有限，只能在表末尾添加列，不能修改列定义，不能删除已有的列。那么如果要修改表呢？我们可以采用临时表的办法。具体来说有四步： 将现有表重命名为临时表； 创建新表； 将临时表的数据导入新表（注意处理修改的列）； 删除临时表。 代码案例如下：123456789101112131415161718192021@Overridepublic void onCreate(SQLiteDatabase db) &#123; createAllTables(db);&#125;@Overridepublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; switch (oldVersion) &#123; case 1: //如果老版本是1，则创建X表 createTableX(db); case 2: //如果老版本是2，则修改表X的结构(例如添加两个字段) upgradeTables(db,\"X\",\"ColA, ColB, ColC, ... ColN\"); break; default: dropAllTables(db); createAllTables(db); break; &#125;&#125; 有个关于小程序之switch…case…break的小片段需要注意一下，case 1之后是没有break的 upgradeTables方法里采用的是数据库事务，利用事务的原子特性（确保工作单位内的所有操作都成功完成，否则，事务会在出现故障时终止，之前的操作也会回滚到以前的状态）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Upgrade tables. In this method, the sequence is: * [1] Rename the specified table as a temporary table. * [2] Create a new table which name is the specified name. * [3] Insert data into the new created table, data from the temporary table. * [4] Drop the temporary table. * * @param db The database. * @param tableName The table name. * @param columns The columns range, format is \"ColA, ColB, ColC, ... ColN\"; */ protected void upgradeTables(SQLiteDatabase db, String tableName, String columns) &#123; try &#123; db.beginTransaction(); // 1, Rename table. String tempTableName = tableName + \"_temp\"; String sql = \"ALTER TABLE \" + tableName +\" RENAME TO \" + tempTableName; execSQL(db, sql, null); // 2, Create table. //onCreateTable(db); createNewTableX(db); // 3, Load data sql = \"INSERT INTO \" + tableName + \" (\" + columns + \") \" + \" SELECT \" + columns + \" FROM \" + tempTableName; execSQL(db, sql, null); // 4, Drop the temporary table. execSQL(db, \"DROP TABLE IF EXISTS \" + tempTableName, null); db.setTransactionSuccessful(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; db.endTransaction(); &#125; &#125; 跨越版本的升级 处理好了单个版本的升级，还有一个更加棘手的问题：如果应用程序发布了多个版本，以致出现了三个以上数据库版本， 如何确保所有的用户升级应用后数据库都能用呢？有两种方式： 方式一：确定 相邻版本 的差别，从版本1开始依次迭代更新，先执行v1到v2，再v2到v3…… 方式二：为 每个版本 确定与现在数据库的差别，为每个case撰写专门的升级代码。 方式一的优点是每次更新数据库的时候只需要在onUpgrade方法的末尾加一段从上个版本升级到新版本的代码，易于理解和维护，缺点是当版本变多之后，多次迭代升级可能需要花费不少时间，增加用户等待； 方式二的优点则是可以保证每个版本的用户都可以在消耗最少的时间升级到最新的数据库而无需做无用的数据多次转存，缺点是强迫开发者记忆所有版本数据库的完整结构，且每次升级时onUpgrade方法都必须全部重写。以上简单分析了两种方案的优缺点，它们可以说在花费时间上是刚好相反的，至于如何取舍，可能还需要结合具体情况分析。 上述升级案例中使用的是方式一 小插曲Failed to open database 某些情况下可以通过重启手机解决，初步分析原因可能是【sdcard状态异常】、【数据库db文件被其它应用占用了，如被手机上的db查看器占用了】使用SQLiteOpenHelper的getReadableDatabase()获得的数据库能不能做写的操作 答案： 可以! 不要被Readable的意思误导啦，readable是可读的意思，但不代表不能写哦。 其实就是考察getReadableDatabase()和getWriteableDatabase()的区别 源码解读区别： 查看源码，发现getReadableDatabase()和getWriteableDatabase()都是调用getDatabaseLocked(boolean writeable) 方法，传不同的参数 getReadableDatabase() 会获取用于操作SQLiteDatabase的实例。getReadableDatabase()会先以读写方式打开数据库，若数据库磁盘空间满了，打开失败，会继续尝试以只读方式打开。若磁盘空间有了，会关闭只读数据库对象，返回可读写数据库对象。 getWriteableDatabase()也是会以读写方式打开数据库，如果磁盘满了，会抛异常，不会返回数据库对象。 其实就是getReadableDatabase()会在抛异常的时候以只读模式打开数据库。而getWritableDatabase()不会 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public SQLiteDatabase getWritableDatabase() &#123; synchronized (this) &#123; return getDatabaseLocked(true); &#125; &#125; public SQLiteDatabase getReadableDatabase() &#123; synchronized (this) &#123; return getDatabaseLocked(false); &#125; &#125; private SQLiteDatabase getDatabaseLocked(boolean writable) &#123; if (mDatabase != null) &#123; if (!mDatabase.isOpen()) &#123; // Darn! The user closed the database by calling mDatabase.close(). mDatabase = null; &#125; else if (!writable || !mDatabase.isReadOnly()) &#123; // The database is already open for business. return mDatabase; &#125; &#125; if (mIsInitializing) &#123; throw new IllegalStateException(\"getDatabase called recursively\"); &#125; SQLiteDatabase db = mDatabase; try &#123; mIsInitializing = true; if (db != null) &#123; if (writable &amp;&amp; db.isReadOnly()) &#123; db.reopenReadWrite(); &#125; &#125; else if (mName == null) &#123; db = SQLiteDatabase.create(null); &#125; else &#123; try &#123; if (DEBUG_STRICT_READONLY &amp;&amp; !writable) &#123; //如果以严格的只读方式打开 //获取db文件的路径 final String path = mContext.getDatabasePath(mName).getPath(); //直接打开数据库 db = SQLiteDatabase.openDatabase(path, mFactory, SQLiteDatabase.OPEN_READONLY, mErrorHandler); &#125; else &#123; //如果以读写方式打开 //打开或创建数据库 db = mContext.openOrCreateDatabase(mName, mEnableWriteAheadLogging ? Context.MODE_ENABLE_WRITE_AHEAD_LOGGING : 0, mFactory, mErrorHandler); &#125; &#125; catch (SQLiteException ex) &#123; //getWritableDatabase()会在抛异常的时候抛出异常 if (writable) &#123; throw ex; &#125; Log.e(TAG, \"Couldn't open \" + mName + \" for writing (will try read-only):\", ex); final String path = mContext.getDatabasePath(mName).getPath(); //getReadableDatabase()会在抛异常的时候以只读模式打开数据库 db = SQLiteDatabase.openDatabase(path, mFactory, SQLiteDatabase.OPEN_READONLY, mErrorHandler); &#125; &#125; ... &#125; 参考链接http://flyingcat2013.blog.51cto.com/7061638/1537074?utm_source=tuicool&amp;utm_medium=referralhttp://www.2cto.com/kf/201507/425862.html","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"SQLite","slug":"SQLite","permalink":"http://yoursite.com/tags/SQLite/"}]},{"title":"Android HTTPS、TLS版本支持相关解决方案","slug":"Android HTTPS、TLS版本支持相关解决方案","date":"2016-12-29T12:47:00.000Z","updated":"2017-08-04T16:33:52.000Z","comments":true,"path":"2016/12/29/Android HTTPS、TLS版本支持相关解决方案/","link":"","permalink":"http://yoursite.com/2016/12/29/Android HTTPS、TLS版本支持相关解决方案/","excerpt":"","text":"前言在互联网安全通信方式上，目前用的最多的就是https配合ssl和数字证书来保证传输和认证安全 简介 结合okhttp实现https访问，并解决其中遇到的问题 okhttp默认情况下是支持https协议的，不过要注意的是，支持https的网站如果是CA机构颁发的证书，默认情况下是可以信任的。 使用Charles进行https抓包 HTTPS相关名词解释 https：在http(超文本传输协议)基础上提出的一种安全的http协议，因此可以称为安全的超文本传输协议。http协议直接放置在TCP协议之上，而https提出在http和TCP中间加上一层加密层。从发送端看，这一层负责把http的内容加密后送到下层的TCP，从接收方看，这一层负责将TCP送来的数据解密还原成http的内容。 SSL(Secure Socket Layer)：是Netscape公司设计的主要用于WEB的安全传输协议。从名字就可以看出它在https协议栈中负责实现上面提到的加密层。因此，一个https协议栈大致是这样的： 补充：IP（网络层）、TCP（传输层），HTTP（应用层），SSL处于TCP和HTTP之间 数字证书：一种文件的名称，好比一个机构或人的签名，能够证明这个机构或人的真实性。其中包含的信息，用于实现上述功能。 加密和认证：加密是指通信双方为了防止敏感信息在信道上被第三方窃听而泄漏，将明文通过加密变成密文，如果第三方无法解密的话，就算他获得密文也无能为力；认证是指通信双方为了确认对方是值得信任的消息发送或接受方，而不是使用假身份的骗子，采取的确认身份的方式。只有同时进行了加密和认真才能保证通信的安全，因此在SSL通信协议中这两者都很重要。 因此，这三者的关系已经十分清楚了：https依赖一种实现方式，目前通用的是SSL，数字证书是支持这种安全通信的文件。另外有SSL衍生出TLS和WTLS，前者是IEFT将SSL标准化之后产生的（TLS1.0），与SSL差别很小，后者是用于无线环境下的TSL。 图解HTTPS协议加密解密全过程我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取。所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。 HTTPS其实是由两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体是如何进行加密，解密，验证的，且看下图。 客户端发起HTTPS请求这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。 服务端的配置采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 传送证书这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 客户端解析证书这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 传送加密信息这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务端解密信息服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 传输加密后的信息这部分信息是服务端用私钥加密后的信息，可以在客户端被还原。 客户端解密信息客户端用之前生成的私钥解密服务端传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。 异常解决问题描述在4.x系统上通过HTTPS进行访问产生如下异常： javax.net.ssl.SSLProtocolException: SSL handshake aborted: ssl=0x65bc0ad8: Failure in SSL library, usually a protocol errorerror:1407743E:SSL routines:SSL23_GET_SERVER_HELLO:tlsv1 alert inappropriate fallback (external/openssl/ssl/s23_clnt.c:744 0x5cf4ed74:0x00000000) 原因Android4.x系统对TLS的支持存在版本差异，具体细节请看以下分析 分析首先我们查看一下Google关于SSLEngine的官方文档说明 这里截取不同Android版本针对于TLS协议的默认配置图如下： 从上图可以得出如下结论： TLSv1.0从API 1+就被默认打开 TLSv1.1和TLSv1.2只有在API 20+ 才会被默认打开 也就是说低于API 20+的版本是默认关闭对TLSv1.1和TLSv1.2的支持，若要支持则必须自己打开 有了以上关于Android SSLEngine相关知识的铺垫，让我们来测试一下这次目标案例的域名 fort.sports.baofeng.com 我们可以在QUALYS SSL LABS测试它对ssl支持的版本这里截取SSL报告中对我们有用的一部分，如下图 刚开始服务器配置只支持TLS1.2，SSL报告的结果也验证了这一点 可以看出大部分2.x、4.x的Android系统都会报Server sent fatal alert：handshake_failure,而5.0、6.0、7.0的Android系统在Hanshake Simulation中表现正常，因为它们支持TLS1.2 这就能解释为什么大部分4.xAndroid系统在进行HTTPS访问时产生上述异常 解决方案 我们首先想到的是，可以让服务器配置兼容支持TLS1.0、TLS1.1、TLS1.2，这样客户端就不需要做任何处理，完美兼容 经过测试，这个是可以的（测试手机包括Lenovo K920 4.4.2，Lenovo K30-E 4.4.4） 我们再次查看SSL报告中的几个关键结果： 从上图可以看出，服务器配置已经可以支持TLS1.0、TLS1.1、TLS1.2从下图可以看出，Handshake Simulation在Android 4.x系统也可以正常运作了 或许，你以为这样就完美了，但是，你有没有想到过这样一种情况，当你所访问的域名服务器只支持TLS1.2，那Android4.x系统应该如何应对那 答案：想办法让Android4.x打开对TLS1.1、TLS1.2的支持 假设你的网络请求库使用的是okhttp，在APP中可以这样初始化OkHttpClient，这里通过在AppParams中配置isBypassAuthen，来判断是否绕过认证，也就是无条件信任所有HTTPS网站 这里只是 单向认证 客户端对服务端证书的单向认证 123456789101112131415161718192021222324252627282930313233private void initHttpsClient() &#123; OkHttpClient.Builder builder = new OkHttpClient.Builder() .connectTimeout(30000L, TimeUnit.MILLISECONDS) .readTimeout(30000L, TimeUnit.MILLISECONDS) .addInterceptor(new LoggerInterceptor(\"OkHttpClient\")) .hostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;); if(AppParams.isBypassAuthen)&#123; HttpsUtils.SSLParams sslParams = HttpsUtils.getSslSocketFactory(null, null, null); builder.sslSocketFactory(sslParams.sSLSocketFactory, sslParams.trustManager); &#125;else&#123; SSLContext sslContext = null; try &#123; sslContext = SSLContext.getInstance(\"TLS\"); try &#123; sslContext.init(null, null, null); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; SSLSocketFactory socketFactory = new Tls12SocketFactory(sslContext.getSocketFactory()); builder.sslSocketFactory(socketFactory,new HttpsUtils.UnSafeTrustManager()); &#125; OkHttpClient okHttpClient = builder .build(); OkHttpUtils.initClient(okHttpClient); &#125; 具体怎么使用HTTPS，参考HttpsUtils： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206public class HttpsUtils&#123; public static class SSLParams &#123; public SSLSocketFactory sSLSocketFactory; public X509TrustManager trustManager; &#125; public static SSLParams getSslSocketFactory(InputStream[] certificates, InputStream bksFile, String password) &#123; SSLParams sslParams = new SSLParams(); try &#123; TrustManager[] trustManagers = prepareTrustManager(certificates); KeyManager[] keyManagers = prepareKeyManager(bksFile, password); SSLContext sslContext = SSLContext.getInstance(\"TLS\"); X509TrustManager trustManager = null; if (trustManagers != null) &#123; trustManager = new MyTrustManager(chooseTrustManager(trustManagers)); &#125; else &#123; trustManager = new UnSafeTrustManager(); &#125; sslContext.init(keyManagers, new TrustManager[]&#123;trustManager&#125;,null); sslParams.sSLSocketFactory = sslContext.getSocketFactory(); sslParams.trustManager = trustManager; return sslParams; &#125; catch (NoSuchAlgorithmException e) &#123; throw new AssertionError(e); &#125; catch (KeyManagementException e) &#123; throw new AssertionError(e); &#125; catch (KeyStoreException e) &#123; throw new AssertionError(e); &#125; &#125; private class UnSafeHostnameVerifier implements HostnameVerifier &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125; public static class UnSafeTrustManager implements X509TrustManager &#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new java.security.cert.X509Certificate[]&#123;&#125;; &#125; &#125; private static TrustManager[] prepareTrustManager(InputStream... certificates) &#123; if (certificates == null || certificates.length &lt;= 0) return null; try &#123; CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\"); KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(null); int index = 0; for (InputStream certificate : certificates) &#123; String certificateAlias = Integer.toString(index++); keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate(certificate)); try &#123; if (certificate != null) certificate.close(); &#125; catch (IOException e) &#123; &#125; &#125; TrustManagerFactory trustManagerFactory = null; trustManagerFactory = TrustManagerFactory. getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore); TrustManager[] trustManagers = trustManagerFactory.getTrustManagers(); return trustManagers; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; private static KeyManager[] prepareKeyManager(InputStream bksFile, String password) &#123; try &#123; if (bksFile == null || password == null) return null; KeyStore clientKeyStore = KeyStore.getInstance(\"BKS\"); clientKeyStore.load(bksFile, password.toCharArray()); KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(clientKeyStore, password.toCharArray()); return keyManagerFactory.getKeyManagers(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (UnrecoverableKeyException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; private static X509TrustManager chooseTrustManager(TrustManager[] trustManagers) &#123; for (TrustManager trustManager : trustManagers) &#123; if (trustManager instanceof X509TrustManager) &#123; return (X509TrustManager) trustManager; &#125; &#125; return null; &#125; private static class MyTrustManager implements X509TrustManager &#123; private X509TrustManager defaultTrustManager; private X509TrustManager localTrustManager; public MyTrustManager(X509TrustManager localTrustManager) throws NoSuchAlgorithmException, KeyStoreException &#123; TrustManagerFactory var4 = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); var4.init((KeyStore) null); defaultTrustManager = chooseTrustManager(var4.getTrustManagers()); this.localTrustManager = localTrustManager; &#125; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; try &#123; defaultTrustManager.checkServerTrusted(chain, authType); &#125; catch (CertificateException ce) &#123; localTrustManager.checkServerTrusted(chain, authType); &#125; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125; &#125;&#125; 自行实现SSLSocketFactory ，实现对TLSv1.1、TLSv1.2的支持123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Tls12SocketFactory extends SSLSocketFactory &#123; private static final String[] TLS_SUPPORT_VERSION = &#123;\"TLSv1.1\", \"TLSv1.2\"&#125;; final SSLSocketFactory delegate; public Tls12SocketFactory(SSLSocketFactory base) &#123; this.delegate = base; &#125; @Override public String[] getDefaultCipherSuites() &#123; return delegate.getDefaultCipherSuites(); &#125; @Override public String[] getSupportedCipherSuites() &#123; return delegate.getSupportedCipherSuites(); &#125; @Override public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException &#123; return patch(delegate.createSocket(s, host, port, autoClose)); &#125; @Override public Socket createSocket(String host, int port) throws IOException, UnknownHostException &#123; return patch(delegate.createSocket(host, port)); &#125; @Override public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException &#123; return patch(delegate.createSocket(host, port, localHost, localPort)); &#125; @Override public Socket createSocket(InetAddress host, int port) throws IOException &#123; return patch(delegate.createSocket(host, port)); &#125; @Override public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException &#123; return patch(delegate.createSocket(address, port, localAddress, localPort)); &#125; private Socket patch(Socket s) &#123; if (s instanceof SSLSocket) &#123; ((SSLSocket) s).setEnabledProtocols(TLS_SUPPORT_VERSION); &#125; return s; &#125;&#125; 参考链接 https://github.com/square/okhttp https://github.com/hongyangAndroid/okhttputils http://blog.csdn.net/joye123/article/details/53888252 https://developer.android.com/reference/javax/net/ssl/SSLEngine.html http://blog.csdn.net/lmj623565791/article/details/48129405 http://blog.csdn.net/shw372029857/article/details/52687906http://www.jb51.net/network/68135.html","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"http://yoursite.com/tags/HTTPS/"}]},{"title":"Android图片加载库的封装实战","slug":"Android图片加载库的封装实战","date":"2016-12-05T11:47:00.000Z","updated":"2017-08-04T10:34:59.000Z","comments":true,"path":"2016/12/05/Android图片加载库的封装实战/","link":"","permalink":"http://yoursite.com/2016/12/05/Android图片加载库的封装实战/","excerpt":"","text":"重磅更新 || 2017-02-16使用ImageLoaderUtil实现一个真正意义的图集功能，持续完善和更新中 Gallery Gallery Gallery 重要的东西贴三遍！ 2017-05-09 || 优化圆形图片加载 更新demo 前言 图片加载是Android开发中最最基础的功能，为了降低开发周期和难度，我们经常会选用一些图片加载的开源库 选取第三方SDK需要谨慎 二次封装 注意：所有改动更新会同步到GitHub主流图片加载库的对比&gt; 共同点 使用简单：一句话实现图片的获取和显示 可配置性高：可配置各种解码、缓存、下载机制 自适应程度高：根据系统性能调整配置策略（如CPU核数决定最大并发数、内存决定内存缓存大小、网络状态变化调整最大并发数） 多级缓存 支持多种数据源 支持多种Displayer 兼容性好（可以配合okhttp等库进行使用）Android-Universal-Image-Loader&gt; 简介 作者：nostra13 面世时间：2011 star数（截止到发稿）：14509 https://github.com/nostra13/Android-Universal-Image-Loader&gt; 优点 支持下载进度监听（ImageLoadingListener） 可在View滚动中暂停图片加载（PauseOnScrollListener） 默认实现多种内存缓存算法（最大最先删除，使用最少最先删除，最近最少使用，先进先删除，当然自己也可以配置缓存算法）&gt; 缺点 从2015.11.27之后不再维护，项目中不建议使用Picasso&gt; 简介 作者：JakeWharton（Square） 面世时间：2012 star数（截止到发稿）：12076 https://github.com/square/picasso&gt; 优点 包较小（100k） 取消不在视野范围内图片资源的加载 使用最少的内存完成复杂的图片转换 自动添加二级缓存 任务调度优先级处理 并发线程数根据网络类型调整 图片的本地缓存交给同为Square出品的okhttp处理，控制图片的过期时间&gt; 缺点 功能较为简单 自身无实现“本地缓存”Glide&gt; 简介 作者：Sam sjudd (Google) 面世时间：2013 star数（截止到发稿）：12067 https://github.com/bumptech/glide&gt; 优点 多种图片格式的缓存，适用于更多的内容表现形式（如Gif、WebP、缩略图、Video） 生命周期集成（根据Activity或者Fragment的生命周期管理图片加载请求） 高效处理Bitmap（bitmap的复用和主动回收，减少系统回收压力） 高效的缓存策略，灵活（Picasso只会缓存原始尺寸的图片，Glide缓存的是多种规格），加载速度快且内存开销小（默认Bitmap格式的不同，使得内存开销是Picasso的一半）&gt; 缺点 方法较多较复杂，因为相当于在Picasso上的改进，包较大（500k），影响不是很大Fresco&gt; 简介 作者：Facebook 面世时间：2015 star数（截止到发稿）：11235 https://github.com/facebook/fresco&gt; 优点 最大的优势在于5.0以下(最低2.3)的bitmap加载。在5.0以下系统，Fresco将图片放到一个特别的内存区域(Ashmem区) 大大减少OOM（在更底层的Native层对OOM进行处理，图片将不再占用App的内存） 适用于需要高性能加载大量图片的场景&gt; 缺点 包较大（2~3M） 用法复杂 底层涉及c++领域，阅读源码深入学习难度大按需选择图片加载库&gt; 图片加载需要支持Gif，之前项目中使用的Android-Universal-Image-Loader不支持Gif且Android-Universal-Image-Loader已经停止维护，遂决定替换图片加载库&gt; 分析完优缺点最终选择Glide的其它理由： Glide是在Picasso的基础上进行改进的（支持Gif，内存开销小），虽然500k左右的包大小相对于Picasso较大，但是这个数量级的影响可以接受 初衷是想一直维持图片的原始ImageView，而 Fresco需要在布局文件中将图片控件声明为库中自定义的SimpleDraweeView，如果切库还需要更改组件，代价会很高 Google推荐（亲儿子），在Google很多开源项目中广泛使用&gt; 但不可避免的是，Glide在使用的过程中依然存在着许多坑需要我们去填！如何更好地封装图片加载库为什么要封装？先从现在面对的情形来看，项目中使用图片加载的地方都是使用的类似下面的语句1ImageLoader.getInstance().displayImage(imageUrl, imageView，options);然而现在ImageLoader已经停止维护且已经无法满足项目需求，我们需要替换，这时你会发现如果换库的话，所有涉及到的地方都要修改（Android-Universal-Image-Loader已经和图片加载的业务逻辑严重地耦合在一起了），工作量可见一斑，这就是不封装在切库时面临的窘境！那怎么解决那？计算机史上有个万能的解决方案就是，如果原有层面解决不了问题，那么就请再加一层！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/** * Created by soulrelay on 2016/10/11 13:42. * Class Note: * use this class to load image,single instance */public class ImageLoaderUtil &#123; //图片默认加载类型 以后有可能有多种类型 public static final int PIC_DEFAULT_TYPE = 0; //图片默认加载策略 以后有可能有多种图片加载策略 public static final int LOAD_STRATEGY_DEFAULT = 0; private static ImageLoaderUtil mInstance; private BaseImageLoaderStrategy mStrategy; public ImageLoaderUtil() &#123; mStrategy = new GlideImageLoaderStrategy(); &#125; //单例模式，节省资源 public static ImageLoaderUtil getInstance() &#123; if (mInstance == null) &#123; synchronized (ImageLoaderUtil.class) &#123; if (mInstance == null) &#123; mInstance = new ImageLoaderUtil(); return mInstance; &#125; &#125; &#125; return mInstance; &#125; /** * 统一使用App context * 可能带来的问题：http://stackoverflow.com/questions/31964737/glide-image-loading-with-application-context * * @param url * @param placeholder * @param imageView */ public void loadImage(String url, int placeholder, ImageView imageView) &#123; mStrategy.loadImage(imageView.getContext(), url, placeholder, imageView); &#125; public void loadGifImage(String url, int placeholder, ImageView imageView) &#123; mStrategy.loadGifImage(url, placeholder, imageView); &#125; public void loadImage(String url, ImageView imageView) &#123; mStrategy.loadImage(url, imageView); &#125; /** * 展示图片加载进度 */ public void loadImageWithProgress(String url, ImageView imageView, ProgressLoadListener listener) &#123; mStrategy.loadImageWithProgress(url,imageView,listener); &#125; public void loadGifWithProgress(String url, ImageView imageView, ProgressLoadListener listener) &#123; mStrategy.loadGifWithProgress(url,imageView,listener); &#125; /** * 策略模式的注入操作 * * @param strategy */ public void setLoadImgStrategy(BaseImageLoaderStrategy strategy) &#123; mStrategy = strategy; &#125; /** * 清除图片磁盘缓存 */ public void clearImageDiskCache(final Context context) &#123; mStrategy.clearImageDiskCache(context); &#125; /** * 清除图片内存缓存 */ public void clearImageMemoryCache(Context context) &#123; mStrategy.clearImageMemoryCache(context); &#125; /** * 根据不同的内存状态，来响应不同的内存释放策略 * * @param context * @param level */ public void trimMemory(Context context, int level) &#123; mStrategy.trimMemory(context, level); &#125; /** * 清除图片所有缓存 */ public void clearImageAllCache(Context context) &#123; clearImageDiskCache(context.getApplicationContext()); clearImageMemoryCache(context.getApplicationContext()); &#125; /** * 获取缓存大小 * * @return CacheSize */ public String getCacheSize(Context context) &#123; return mStrategy.getCacheSize(context); &#125;&#125;所有需要图片显示的地方使用如下方法进行调用：&gt; 入口唯一，所有图片加载都在ImageLoaderUtil这一个地方统一管理，使用了单例模式(据说单元素的枚举类型已经成为实现Singleton的最佳方法，你可以试试 )，&gt; 高效地封装减少了切库(只需要切换图片加载策略)带来的代价，默认采用GlideImageLoaderStrategy总结：外部表现一致，内部灵活处理原则。1234567891011121314151617181920212223242526272829/** * 图片加载库的封装演示案例 * Created by soulrelay on 2016/12/11 19:18 */public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.iv_normal) ImageView ivNormal; @BindView(R.id.iv_gif) ImageView ivGif; @BindView(R.id.iv_gif1) ImageView ivGif1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); initView(); &#125; private void initView() &#123; ImageLoaderUtil.getInstance().loadImage(\"http://image.sports.baofeng.com/25a3dbb0c99c5e48e52e60941ed230be\", R.drawable.bg_default_video_common_small, ivNormal); ImageLoaderUtil.getInstance().loadImage(\"http://image.sports.baofeng.com/19ce5d6ac3b4fff255196f200b1d3079\", R.drawable.bg_default_video_common_small, ivGif); ImageLoaderUtil.getInstance().loadGifImage(\"http://image.sports.baofeng.com/19ce5d6ac3b4fff255196f200b1d3079\", R.drawable.bg_default_video_common_small, ivGif1); &#125;&#125;效果图如下所示：使用策略模式封装图片加载策略如果你对策略模式不是很熟，请先参考策略模式和状态模式首先我们需要抽象出一个图片加载的基础接口BaseImageLoaderStrategy基本功能主要包括&gt; 正常加载图片&gt; 针对于GIF图片的特殊加载&gt; 加载图片的进度回调&gt; 清除缓存&gt; 获取缓存大小等&gt; 其它特殊需求自己封装，最好不要破坏策略模式的整体结构123456789101112131415161718192021222324252627282930/** * Created by soulrelay on 2016/10/11. * Class Note: * abstract class/interface defined to load image * (Strategy Pattern used here) */public interface BaseImageLoaderStrategy &#123; //无占位图 void loadImage(String url, ImageView imageView); void loadImage(String url, int placeholder, ImageView imageView); void loadImage(Context context, String url, int placeholder, ImageView imageView); void loadGifImage(String url, int placeholder, ImageView imageView); void loadImageWithProgress(String url, ImageView imageView, ProgressLoadListener listener); void loadGifWithProgress(String url, ImageView imageView, ProgressLoadListener listener); //清除硬盘缓存 void clearImageDiskCache(final Context context); //清除内存缓存 void clearImageMemoryCache(Context context); //根据不同的内存状态，来响应不同的内存释放策略 void trimMemory(Context context, int level); //获取缓存大小 String getCacheSize(Context context);&#125;需要说明的一点是：&gt; 当封装的方法参数比较少时可以按照上述方式进行抽象，如果需要传递的参数较多，可以考虑使用建造者模式建造者模式&gt; 例如封装一个ImageLoaderConfiguration，包含如下参数等等，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 type 图片加载的类型（大图、小图、中图） url 需要解析的url placeHolder 当没有成功加载的时候显示的图片 imgView ImageView的实例 loadStrategy 加载策略&gt; 当然这里我没有使用建造模式，考虑到目前使用的对象还不算复杂（传参比较简单），而且如果使用建造者模式有可能每次都要new一个新的对象实例，虽然开销可以接受&gt; 使用ImageLoaderUtil的过程中，注意内存泄露的问题（静态单例的生命周期与App一样，当一个单例的对象长久不用时，不会被垃圾收集机制回收）然后基于每个图片库的各自方式来进行相应策略的封装，需要使用哪种策略，只需要通过ImageLoaderUtil的setLoadImgStrategy(BaseImageLoaderStrategy strategy)方法将相应的策略注入，相关类图关系如下所示：不同的图片加载库实现不同的图片加载策略这里只是给出Glide的图片加载策略类GlideImageLoaderStrategy作为参考&gt; Glide依赖v4包，且需要配置android.permission.INTERNET和android.permission.WRITE_EXTERNAL_STORAGE（忘记配置权限，图片加载不出来，还看不出什么异常）&gt; 其中部分方法使用到了RequestListener的回调（这里是因为项目中的一些特殊需求而添加，如统计图片首次加载时长来测试一下图片cdn服务器的速度等）&gt; 在使用Glide的过程中遇到了一些问题，部分已经在注释中说明&gt; 之所以针对gif单独封装，是因为在使用的过程中发现，当在列表中加载大量gif会有OOM的问题，所以通过asGif进行特殊标明，即使这样也会出现类似问题，同时暂时通过skipMemoryCache(true)跳过内存缓存，之后有更好的办法会继续补充，各位看官如有良策，希望可以不吝赐教&gt; Glide本身不提供图片的progress回调，所以关于进度回调的解决方案参照的是ProgressGlide，并做了些许改动集成到项目中&gt; 期间发现了一个很好的问题Android的App中线程池的使用，具体使用多少个线程池？，其中一个答主的关于图片加载库线程池策略的分析很好，值得体会，简单摘录如下： UIL的线程池处理非常简单粗暴，没有根据CPU数量来选择，也没有根据网络状况的变化进行调整; Picasso的线程池会根据网络状况的变化进行调整，在Wifi下线程数为4,而4G下线程数为3, 3G下为2， 2G下为1，默认状况为3； Glide加载缓存未命中的线程池会根据根据CPU的数量和Java虚拟机中可用的处理器数量来选择合适的线程数，但是最多不超过4;而加载缓存命中的图片的线程池默认大小为1.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/** * Created by soulrelay on 2016/10/11 13:48. * Class Note: * using &#123;@link Glide&#125; to load image */public class GlideImageLoaderStrategy implements BaseImageLoaderStrategy &#123; @Override public void loadImage(String url, int placeholder, ImageView imageView) &#123; loadNormal(imageView.getContext(), url, placeholder, imageView); &#125; @Override public void loadImage(Context context, String url, int placeholder, ImageView imageView) &#123; loadNormal(context, url, placeholder, imageView); &#125; /** * 无holder的gif加载 * * @param url * @param imageView */ @Override public void loadImage(String url, ImageView imageView) &#123; Glide.with(imageView.getContext()).load(url).dontAnimate() .placeholder(imageView.getDrawable()) .diskCacheStrategy(DiskCacheStrategy.SOURCE) .into(imageView); &#125; @Override public void loadGifImage(String url, int placeholder, ImageView imageView) &#123; loadGif(imageView.getContext(), url, placeholder, imageView); &#125; @Override public void loadImageWithProgress(String url, final ImageView imageView, final ProgressLoadListener listener) &#123; Glide.with(imageView.getContext()).using(new ProgressModelLoader(new ProgressUIListener() &#123; @Override public void update(final int bytesRead, final int contentLength) &#123; imageView.post(new Runnable() &#123; @Override public void run() &#123; listener.update(bytesRead, contentLength); &#125; &#125;); &#125; &#125;)).load(url).asBitmap().dontAnimate(). listener(new RequestListener&lt;Object, Bitmap&gt;() &#123; @Override public boolean onException(Exception e, Object model, Target&lt;Bitmap&gt; target, boolean isFirstResource) &#123; listener.onException(); return false; &#125; @Override public boolean onResourceReady(Bitmap resource, Object model, Target&lt;Bitmap&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123; listener.onResourceReady(); return false; &#125; &#125;).into(imageView); &#125; @Override public void loadGifWithProgress(String url, final ImageView imageView, final ProgressLoadListener listener) &#123; Glide.with(imageView.getContext()).using(new ProgressModelLoader(new ProgressUIListener() &#123; @Override public void update(final int bytesRead, final int contentLength) &#123; imageView.post(new Runnable() &#123; @Override public void run() &#123; listener.update(bytesRead, contentLength); &#125; &#125;); &#125; &#125;)).load(url).asGif().skipMemoryCache(true).dontAnimate(). listener(new RequestListener&lt;String, GifDrawable&gt;() &#123; @Override public boolean onException(Exception e, String model, Target&lt;GifDrawable&gt; target, boolean isFirstResource) &#123; listener.onException(); return false; &#125; @Override public boolean onResourceReady(GifDrawable resource, String model, Target&lt;GifDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123; listener.onResourceReady(); return false; &#125; &#125;).into(imageView); &#125; @Override public void clearImageDiskCache(final Context context) &#123; try &#123; if (Looper.myLooper() == Looper.getMainLooper()) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Glide.get(context.getApplicationContext()).clearDiskCache(); &#125; &#125;).start(); &#125; else &#123; Glide.get(context.getApplicationContext()).clearDiskCache(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void clearImageMemoryCache(Context context) &#123; try &#123; if (Looper.myLooper() == Looper.getMainLooper()) &#123; //只能在主线程执行 Glide.get(context.getApplicationContext()).clearMemory(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void trimMemory(Context context, int level) &#123; Glide.get(context).trimMemory(level); &#125; @Override public String getCacheSize(Context context) &#123; try &#123; return CommonUtils.getFormatSize(CommonUtils.getFolderSize(Glide.getPhotoCacheDir(context.getApplicationContext()))); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return \"\"; &#125; /** * load image with Glide */ private void loadNormal(final Context ctx, final String url, int placeholder, ImageView imageView) &#123; /** * 为其添加缓存策略,其中缓存策略可以为:Source及None,None及为不缓存,Source缓存原型.如果为ALL和Result就不行.然后几个issue的连接: https://github.com/bumptech/glide/issues/513 https://github.com/bumptech/glide/issues/281 https://github.com/bumptech/glide/issues/600 modified by xuqiang */ //去掉动画 解决与CircleImageView冲突的问题 这个只是其中的一个解决方案 //使用SOURCE 图片load结束再显示而不是先显示缩略图再显示最终的图片（导致图片大小不一致变化） final long startTime = System.currentTimeMillis(); Glide.with(ctx).load(url).dontAnimate() .placeholder(placeholder) .diskCacheStrategy(DiskCacheStrategy.SOURCE).listener(new RequestListener&lt;String, GlideDrawable&gt;() &#123; @Override public boolean onException(Exception e, String model, Target&lt;GlideDrawable&gt; target, boolean isFirstResource) &#123; return false; &#125; @Override public boolean onResourceReady(GlideDrawable resource, String model, Target&lt;GlideDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123; return false; &#125; &#125;) .into(imageView); &#125; /** * load image with Glide */ private void loadGif(final Context ctx, String url, int placeholder, ImageView imageView) &#123; final long startTime = System.currentTimeMillis(); Glide.with(ctx).load(url).asGif().dontAnimate() .placeholder(placeholder).skipMemoryCache(true) .diskCacheStrategy(DiskCacheStrategy.SOURCE).listener(new RequestListener&lt;String, GifDrawable&gt;() &#123; @Override public boolean onException(Exception e, String model, Target&lt;GifDrawable&gt; target, boolean isFirstResource) &#123; return false; &#125; @Override public boolean onResourceReady(GifDrawable resource, String model, Target&lt;GifDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123; return false; &#125; &#125;) .into(imageView); &#125;&#125;源码地址ImageLoaderUtil部分参考链接http://www.jianshu.com/p/97994c9693f9https://www.zhihu.com/question/37804956http://www.jianshu.com/p/e26130a93289http://www.cnblogs.com/android-blogs/p/5737611.html更新 2016-12-09 ll You must not call setTag() on a view Glide is targeting 项目中在使用Glide图片加载框架时遇到该错误报错原因大致是因为Glide加载的iamgeView调用了setTag()方法导致的错误，因为Glide已经默认为ImageView设置的Tag 相关解决方案已经在Glide 3.6.0（issue #370）被引进，实测可行在AndroidManifest.xml中加入 12&lt;application android:name=\".App\"&gt; 然后在App中添加如下代码： 123456public class App extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); ViewTarget.setTagId(R.id.glide_tag); &#125;&#125; 在src/main/values/ids.xml添加如下代码： 123&lt;resources&gt; &lt;item type=\"id\" name=\"glide_tag\" /&gt;&lt;/resources&gt; 2016-12-13 ll 添加loadGifWithPrepareCall方法2016.12.13 只想知道图片是否准备完毕（包括来自网络或者sdcard），区别于loadImageWithProgress和loadGifWithProgress的进度回调 Tips：使用Glide加载图片注意ImageView的Scaletype的设置123public interface BaseImageLoaderStrategy &#123; void loadGifWithPrepareCall(String url, ImageView imageView, SourceReadyListener listener);&#125; 123456789101112131415161718192021public class GlideImageLoaderStrategy implements BaseImageLoaderStrategy &#123; @Override public void loadGifWithPrepareCall(String url, ImageView imageView, final SourceReadyListener listener) &#123; Glide.with(imageView.getContext()).load(url).asGif().dontAnimate() .skipMemoryCache(true) .diskCacheStrategy(DiskCacheStrategy.SOURCE). listener(new RequestListener&lt;String, GifDrawable&gt;() &#123; @Override public boolean onException(Exception e, String model, Target&lt;GifDrawable&gt; target, boolean isFirstResource) &#123; return false; &#125; @Override public boolean onResourceReady(GifDrawable resource, String model, Target&lt;GifDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123; listener.onResourceReady(resource.getIntrinsicWidth(),resource.getIntrinsicHeight()); return false; &#125; &#125;).into(imageView); &#125;&#125; 12345public class ImageLoaderUtil &#123; public void loadGifWithPrepareCall(String url, ImageView imageView, SourceReadyListener listener) &#123; mStrategy.loadGifWithPrepareCall(url,imageView,listener); &#125;&#125; 2016-12-26 ll 更新loadGifWithProgress方法 2017-1-10 ll 统一加载图片进度回调方法为loadImageWithProgress，弃用并删除loadGifWithProgress方法 具体细节查看GitHub最新代码 2016-12-26 ll 自定义GlideModule 并将 Glide与okhttp3集成 1.自定义一个GlideModule1234567891011121314151617181920212223/** * DES：自定义一个GlideModule * &lt;p&gt; * GlideModule 是一个抽象方法，全局改变 Glide 行为的一个方式， * 通过全局GlideModule 配置Glide，用GlideBuilder设置选项，用Glide注册ModelLoader等。 * &lt;p&gt; */public class MyGlideModule implements GlideModule &#123; @Override public void applyOptions(Context context, GlideBuilder builder) &#123; // Apply options to the builder here. int maxMemory = (int) Runtime.getRuntime().maxMemory();//获取系统分配给应用的总内存大小 int memoryCacheSize = maxMemory / 8;//设置图片内存缓存占用八分之一 //设置内存缓存大小 builder.setMemoryCache(new LruResourceCache(memoryCacheSize)); builder.setBitmapPool(new LruBitmapPool(memoryCacheSize)); &#125; @Override public void registerComponents(Context context, Glide glide) &#123; // register ModelLoaders here. &#125;&#125; 2.AndroidManifest.xml注册1234567891011&lt;manifest ...&gt; &lt;!-- ... permissions --&gt; &lt;application ...&gt; &lt;!-- 自定义GlideModule --&gt; &lt;meta-data android:name=\"com.baofeng.soulrelay.utils.imageloader.MyGlideModule\" android:value=\"GlideModule\" /&gt; &lt;!-- 自定义GlideModule --&gt; &lt;!-- ... activities and other components --&gt; &lt;/application&gt;&lt;/manifest&gt; 3、 Glide与OkHttp3集成 12compile 'com.squareup.okhttp3:okhttp:3.4.2'compile 'com.github.bumptech.glide:okhttp3-integration:1.4.0@aar' 4、添加混淆处理 12345678910111213#--------------------Glide-----------------------#-keep public class * implements com.bumptech.glide.module.GlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** &#123; **[] $VALUES; public *;&#125;-keepnames class com.baofeng.soulrelay.utils.imageloader.MyGlideModule# or more generally:-keep public class * implements com.bumptech.glide.module.GlideModule-keep class com.bumptech.glide.integration.okhttp3.OkHttpGlideModule#--------------------Glide-----------------------# 2017-1-6 ll GIF帧显示不完全 2017-1-10补充说明PS相关问题在issues1649中被提到和解决（目前glide:3.7.0的确存在这个问题）具体解决方法是： glide:3.8.0-SNAPSHOT修复了关于GIF展示的一些bug，实测可用 Gradle配置修改如下： Add the snapshot repo to your list of repositories: 1234567repositories &#123; jcenter() maven &#123; name 'glide-snapshot' url 'http://oss.sonatype.org/content/repositories/snapshots' &#125;&#125; And then change your dependencies to the v3 snapshot version: 1234dependencies &#123; compile 'com.github.bumptech.glide:glide:3.8.0-SNAPSHOT' compile 'com.github.bumptech.glide:okhttp-integration:1.5.0-SNAPSHOT'&#125; 2017-1-10补充说明PSPS：提供一个gif图 帧提取工具GIFFrame.exe据我分析，那些没有显示完整的GIF图片，里面的部分帧图片本身就不是完整的，但是之前的Glide并没有做很好的处理，所以显示效果有缺陷，当然最新的3.8.0-SNAPSHOT解决了这个问题，但是在显示的时候仍有瑕疵（有一些重叠，当然我觉得这也跟gif图的做工有关） 2017-1-6 ll You cannot start a load for a destroyed activity完整异常信息：1234567891011121314151617181920212223FATAL EXCEPTION: mainProcess: com.sports.baofeng, PID: 9170java.lang.IllegalArgumentException: You cannot start a load for a destroyed activityat com.bumptech.glide.d.k.b(SourceFile:134)at com.bumptech.glide.d.k.a(SourceFile:102)at com.bumptech.glide.d.k.a(SourceFile:87)at com.bumptech.glide.i.c(SourceFile:629)at com.storm.durian.common.utils.imageloader.b.a(SourceFile:1194)at com.storm.durian.common.utils.imageloader.c.a(SourceFile:52)at com.sports.baofeng.specialtopic.SpecialTopicDetailFixActivity.a(SourceFile:311)at com.sports.baofeng.specialtopic.SpecialTopicDetailFixActivity.a(SourceFile:1347)at com.sports.baofeng.specialtopic.d.a(SourceFile:1052)at com.sports.baofeng.specialtopic.c$1.a(SourceFile:1064)at com.storm.durian.common.b.b$1.onPostExecute(SourceFile:57)at android.os.AsyncTask.finish(AsyncTask.java:651)at android.os.AsyncTask.access$500(AsyncTask.java:180)at android.os.AsyncTask$InternalHandler.handleMessage(AsyncTask.java:668)at android.os.Handler.dispatchMessage(Handler.java:102)at android.os.Looper.loop(Looper.java:158)at android.app.ActivityThread.main(ActivityThread.java:7225)at java.lang.reflect.Method.invoke(Native Method)at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1230)at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1120) 以上异常出现的几率为random初步分析原因是：进入页面然后又迅速退出，导致AsyncTask中的onPostExecute在调用Glide加载图片时出现如上异常，当然也跟对AsyncTask的管理有关同样的问题参考issues138简单的摘要： you fire an async task and then finish() in which case you just need to pass getApplicationContext instead of this when creating the callback/asynctask 按照上面这个理解的话，如果是在AsyncTask中的onPostExecute执行时调用Glide加载图片，context最好使用ApplicationContext 对ImageLoaderUtil做如下更新，添加方法 BaseImageLoaderStrategy 12//这里的context指定为ApplicationContext void loadImageWithAppCxt(String url, ImageView imageView); GlideImageLoaderStrategy 1234567@Override public void loadImageWithAppCxt(String url, ImageView imageView) &#123; Glide.with(imageView.getContext().getApplicationContext()).load(url).dontAnimate() .placeholder(imageView.getDrawable()) .diskCacheStrategy(DiskCacheStrategy.SOURCE) .into(imageView); &#125; ImageLoaderUtil 123public void loadImageWithAppCxt(String url, ImageView imageView) &#123; mStrategy.loadImageWithAppCxt(url,imageView); &#125; 2017-1-10 ll 简单说说图片适配的问题过多的概念不赘述，可以先参考Android屏幕适配全攻略(最权威的官方适配指导)这里主要描述一种现象，明白的话自然觉得很简单！ 123456&lt;ImageView android:id=\"@+id/iv_gif\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:scaleType=\"centerInside\" /&gt; 假设现在要加载一张200px 200px的GIF图片（图片基于1280 720），这张图片的宽高设置为wrap_content，如果在1920 1080分辨率的手机上显示，相对于1280 720（假设屏幕尺寸相同），在视觉效果上会显得小，这其实是Android系统基于手机像素密度的一种自适配，单一变化条件下，1920 1080分辨率的手机的像素密度是1280 720的1.5倍假设如果系统的自适配让你觉得在高分辨率手机上显得图片过小（像素密度高，200个像素显示起来就比较挤），可以通过自己的计算来改变这种现象ImageLoaderUtil提供如下加载成功回调的方法（并且会把图片的宽高告诉你）：这里有个参数设置，看需求来计算，粗略点可以只使用宽度比例来算，如下面的例子显示，参数为AppParams.screenWidth / 720，当然也可以获取屏幕密度，1920 1080的屏幕密度为3，1280 720的为2，所以参数可以设置为AppParams.density/2（在两种分辨率上看着视觉上一样） 12345678910ImageLoaderUtil.getInstance().loadGifWithPrepareCall(url, mImageView, new SourceReadyListener() &#123; @Override public void onResourceReady(int width, int height) &#123; ViewGroup.LayoutParams params = mImageView.getLayoutParams(); params.height = height * AppParams.screenWidth / 720; params.width = width * AppParams.screenWidth / 720; mImageView.setLayoutParams(params); progressBar.setVisibility(View.GONE); &#125; &#125;); 2017-1-10 ll 添加saveImage方法，实现图片的本地自定义保存功能已同步到GitHub ImageLoaderUtil ImageLoaderUtil相关接口： 12345678910 /** * @param context * @param url 图片url * @param savePath 保存路径 * @param saveFileName 保存文件名 * @param listener 文件保存成功与否的监听器 */public void saveImage(Context context, String url, String savePath, String saveFileName, ImageSaveListener listener) &#123; mStrategy.saveImage(context, url, savePath, saveFileName, listener); &#125; 在工作线程中调用示例如下： 12345678910111213ImageLoaderUtil.getInstance().saveImage(getActivity(), url, Environment.getExternalStorageDirectory().getAbsolutePath() + \"/bfsports\", \"bfsports\" + System.currentTimeMillis(), new ImageSaveListener() &#123; @Override public void onSaveSuccess() &#123; handler.obtainMessage(MSG_PIC_SAVE_SUCC).sendToTarget(); &#125; @Override public void onSaveFail() &#123; handler.obtainMessage(MSG_PIC_SAVE_FAIL).sendToTarget(); &#125; &#125;); 2017-03-08 ll Glide圆形图片加载封装 之前加载圆形图片，一般都是采用自定义的CircleImageview。后来开始使用Glide加载图片，期间遇到Glide和CircleImageview使用冲突的问题（如：有的图片第一次加载的时候只显示占位图，第二次才显示正常的图片，以及CircleImageview带来的崩溃问题），当时采用了一个牺牲动画效果的解决方案 既然已经全面使用Glide，那么就尽量基于Glide来完成加载圆形图片的方案 具体方案请参考Glide圆形图片加载封装","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Glide","slug":"Glide","permalink":"http://yoursite.com/tags/Glide/"},{"name":"图片加载库","slug":"图片加载库","permalink":"http://yoursite.com/tags/图片加载库/"}]},{"title":"VerticalViewPager与VertialTabLayout的结合使用","slug":"VerticalViewPager与VertialTabLayout的结合使用","date":"2016-11-10T07:47:00.000Z","updated":"2017-08-04T16:22:27.000Z","comments":true,"path":"2016/11/10/VerticalViewPager与VertialTabLayout的结合使用/","link":"","permalink":"http://yoursite.com/2016/11/10/VerticalViewPager与VertialTabLayout的结合使用/","excerpt":"","text":"前言在开发中，我们常常需要ViewPager结合Fragment一起使用.我们可以使用三方开源的PagerSlidingTabStrip去实现，或者viewpagerindicator。现在我们可以使用Design support library库的TabLayout去实现了。 TabLayout+ViewPager+Fragment成为了实现如下效果的标配（效果图来自 暴风体育Android APP） 不过这不是重点，重点是我们要实现的下图所示效果：垂直的TabLayout以及垂直的ViewPager，并完成二者的联动： 下面这张是我分享的Demo示意图： 问题这里不对相关代码做过多说明，使用的Github上造好的轮子，然后根据自己的业务需求做的相关改动，因为时间比较紧，这里聊聊期间碰到的困难 方案调研过程中，第一套方案采用的VerticalViewPager继承自ViewPager，通过将Event的横向和纵向坐标进行交换完成ViewPager的垂直效果，但是会出现滑动冲突，即配合嵌套有RecyclerView或者ListView的Fragment会出现向下滑动不灵敏的问题，指定时间内解决效果不理想，用户体验不好 ，暂时放弃、 第二套解决方案使用的VerticalViewPager继承自ViewGroup，按照作者的说明（Small library allowing you to have a VerticalViewPager. It’s just a copy paste from the v19 ViewPager available in the support lib, where I changed all the left/right into top/bottom and X into Y.），同时代码解决了（VerticalViewPager scroll doesnt work when listview is used inside one of the fragment）的问题，结合VerticalTabLayout完美使用 通过VerticalTabLayout的OnTabSelectedListener与VerticalViewPager的OnPageChangeListener完成二者之间的联动，通过VerticalViewPager的PageTransformer完成垂直ViewPager的自定义切换效果 VerticalTabLayout和VerticalViewPager通过线性布局水平放置，使用layout_weight进行比例分割，注意layout_width设置为0，否则可能导致右边VerticalViewPager中嵌套的数据显示不居中的问题 期间设置Fragment时碰到一个没有解决的问题（Fragment with ViewPager setCustomAnimations not working），有知识的大大望不吝赐教 还有就是业务逻辑 接口设计方面的问题，我觉得如果有相关竞品，相对成熟的可以作为参考（反编译APK查看布局代码，抓包查看相关接口和请求机制），为我们提供一种思路，然后基于我们自己的需求取其精华弃其糟粕 源码下载CSDN下载地址GitHub地址 参考链接VerticalTabLayoutVerticalViewPagerandroid design library提供的TabLayout的用法","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"VerticalViewPager","slug":"VerticalViewPager","permalink":"http://yoursite.com/tags/VerticalViewPager/"},{"name":"VertialTabLayout","slug":"VertialTabLayout","permalink":"http://yoursite.com/tags/VertialTabLayout/"}]},{"title":"基于ToolBar等MD相关控件实现的沉浸式联动效果","slug":"基于ToolBar等MD相关控件实现的沉浸式联动效果","date":"2016-09-30T05:50:00.000Z","updated":"2016-09-30T05:52:46.000Z","comments":true,"path":"2016/09/30/基于ToolBar等MD相关控件实现的沉浸式联动效果/","link":"","permalink":"http://yoursite.com/2016/09/30/基于ToolBar等MD相关控件实现的沉浸式联动效果/","excerpt":"","text":"前言 提前下班了！！！ 综述先来看一下最终的效果图 功能点1、CoordinatorLayout、AppBarLayout、CollapsingToolbarLayout、Toolbar、TabLayout、ViewPager联动使用 2、联动过程中保持沉浸式状态栏效果 3、ToolBar的基本使用，如自定义居中的title， Toolbar和Menu的结合使用，自定义溢出菜单样式期间会涉及控件各种属性的设置，这个比较细碎中间遇到一个问题，就是给menu，navigation等设置图片时，图片被拉伸（原因：把基于1280*720的切图放在了drawable文件夹下了，应该放在drawable-xhdpi）4、解决应用启动白屏的问题 各个突破设置ToolBar1234567891011121314151617181920212223242526272829303132333435363738private void setupToolbar() &#123; toolbar = (Toolbar) findViewById(R.id.toolbar); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; int statusBarHeight = getStatusBarHeight(this); FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) toolbar.getLayoutParams(); layoutParams.topMargin = statusBarHeight; &#125; appbar = (AppBarLayout) findViewById(R.id.appbar); setSupportActionBar(toolbar); getSupportActionBar().setDisplayHomeAsUpEnabled(true); //使用系统自带的返回按钮 getSupportActionBar().setHomeAsUpIndicator(R.drawable.icon_back_normal);//替换系统自带的返回图标 toolbar.setOnMenuItemClickListener(onMenuItemClick); &#125; private Toolbar.OnMenuItemClickListener onMenuItemClick = new Toolbar.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem menuItem) &#123; switch (menuItem.getItemId()) &#123; case R.id.action_share: Toast.makeText(MainActivity.this, &quot;收藏&quot;, Toast.LENGTH_SHORT).show(); //其余的省略 break; &#125; return true; &#125; &#125;; private void setupCollapsingToolbar() &#123; collapseToolbar = (CollapsingToolbarLayout) findViewById( R.id.collapse_toolbar); collapseToolbar.setTitleEnabled(false); &#125; OnOffsetChangedListener联动显示实现AppBarLayout的OnOffsetChangedListener 1234567891011121314151617181920212223242526272829303132333435 @Override protected void onResume() &#123; super.onResume(); appbar.addOnOffsetChangedListener(this); &#125; @Override protected void onPause() &#123; super.onPause(); appbar.removeOnOffsetChangedListener(this); &#125;@Override public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) &#123; if (lastPosition == verticalOffset) &#123; return; &#125; lastPosition = verticalOffset; if (verticalOffset == 0) &#123; getSupportActionBar().setTitle(&quot;&quot;); btnRight.setVisibility(View.GONE); viewTitle.setPadding(0, 6, 0, 0); toolbarTitle.setText(&quot;&quot;); return; &#125; else if (verticalOffset &lt; -dip2px(this, 110)) &#123; viewTitle.setPadding(0, 0, 0, 0); getSupportActionBar().setTitle(&quot;&quot;); btnRight.setVisibility(View.GONE); toolbarTitle.setText(&quot;&quot;); &#125; else &#123; viewTitle.setPadding(0, 6, 0, 0); getSupportActionBar().setTitle(&quot;&quot;); toolbarTitle.setText(&quot;军团再临&quot;); btnRight.setVisibility(View.VISIBLE); &#125; &#125; 自定义溢出菜单样式定义样式 123456789&lt;!--溢出菜单样式 --&gt; &lt;style name=&quot;OverflowMenuStyle&quot; parent=&quot;@style/Widget.AppCompat.Light.PopupMenu.Overflow&quot;&gt; &lt;item name=&quot;overlapAnchor&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;android:dropDownWidth&quot;&gt;wrap_content&lt;/item&gt; &lt;item name=&quot;android:paddingRight&quot;&gt;5dp&lt;/item&gt; &lt;item name=&quot;android:popupBackground&quot;&gt;@color/dcdcdc&lt;/item&gt; &lt;item name=&quot;android:dropDownVerticalOffset&quot;&gt;4dip&lt;/item&gt; &lt;item name=&quot;android:dropDownHorizontalOffset&quot;&gt;-4dip&lt;/item&gt; &lt;/style&gt; 添加到application theme中（前两个属性是为了解决启动白屏的问题） Android 启动白屏或者黑屏闪现解决12345&lt;style name=&quot;Theme.AppStartLoadTranslucent&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;!--&lt;item name=&quot;actionOverflowMenuStyle&quot;&gt;@style/OverflowMenuStyle&lt;/item&gt;--&gt; &lt;/style&gt; AndroidManifest.xml设置theme为Theme.AppStartLoadTranslucent1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.soulrelay.coordinatorlayoutdemo&quot;&gt; &lt;!-- To access Google+ APIs: --&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.AppStartLoadTranslucent&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 其实，之前实现类似菜单功能采用popupwindow居多 Toolbar中Menu中图标不显示的问题在menu中，图标不会显示。有的人是采用 onMenuOpened() 来写，可是仍然会有问题，对于AppCompactActivity你可以把onPrepareOptionsPanel（View v，Menu menu）代替 onMenuOpened() 。 123456789101112131415@Override protected boolean onPrepareOptionsPanel(View view, Menu menu) &#123; if (menu != null) &#123; if (menu.getClass() == MenuBuilder.class) &#123; try &#123; Method m = menu.getClass().getDeclaredMethod(&quot;setOptionalIconsVisible&quot;, Boolean.TYPE); m.setAccessible(true); m.invoke(menu, true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; return super.onPrepareOptionsPanel(view, menu); &#125; toolbar menu中app:showAsAction各个属性值作用android:showAsAction。这个属性可接受的值有： always：使菜单项一直显示在ToolBar上。 ifRoom：如果有足够的空间，这个值会使菜单项显示在ToolBar上。 never：使菜单项永远都不出现在ToolBar上,在…的子项中显示。 withText：使菜单项和它的图标，菜单文本一起显示。源码下载联盟-暗影之月-传送门参考链接Android布局属性android:clipToPadding的UI设计妙用Android开发：最详细的 Toolbar 开发实践总结fitsSystemWindows","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Material Design","slug":"Material-Design","permalink":"http://yoursite.com/tags/Material-Design/"},{"name":"ToolBar","slug":"ToolBar","permalink":"http://yoursite.com/tags/ToolBar/"}]},{"title":"列表全家桶之刷新、加载更多、悬浮、左滑删除","slug":"列表全家桶之刷新、加载更多、悬浮、左滑删除","date":"2016-09-26T02:44:00.000Z","updated":"2016-09-26T03:47:38.000Z","comments":true,"path":"2016/09/26/列表全家桶之刷新、加载更多、悬浮、左滑删除/","link":"","permalink":"http://yoursite.com/2016/09/26/列表全家桶之刷新、加载更多、悬浮、左滑删除/","excerpt":"","text":"需求直播入口 功能点 下拉刷新历史数据（这里自定义了refresh header，颠球，射门一气呵成~~） 上拉加载更多比赛 时间头悬浮 两个“今天”的定位锚点 内部相关的业务模型采用MVP构建算是对Android-architecture之MVC、MVP、MVVM、Data-Binding中的MVP进一步的升级，抽取出了BasePresenter、BaseView、MVPBaseActivity、MVPBaseFragment，并通过使用弱引用预防可能发生的内存泄露问题这里就不做赘述，后续有时间会整理一下（基于MVP模型构建多接口，多嵌套复杂数据类型，多视图的的多交互模型） 我的预约 功能点 相对于直播入口少了些相关交互功能 增加了左滑删除取消预约的功能 还有一个隐藏功能，就是多页面的比赛预约同步处理，这里采用EventBus事件总线库进行组件间的通信，然后根据通知做相应的业务处理实战控件原型搭建秉着不重复造轮子的宗旨，使用了如下著名的开源控件 悬浮头置顶功能 StickyListHeaders An android library for section headers that stick to the top https://github.com/emilsjolander/StickyListHeaders 下拉刷新 上拉加载更多 SwipeToLoadLayout A reusable pull-to-refresh and pull-to-loadmore widget https://github.com/Aspsine/SwipeToLoadLayout 左滑删除见代码中的SwipeLayout，暂时找不到来源了 最终的效果图这个是在StickyListHeaders的基础上，整合了SwipeToLoadLayout和SwipeLayout 注意： 基于项目需求对部分开源控件做了相应的调整 源码下载军团再临传送门","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"StickyListHeaders","slug":"StickyListHeaders","permalink":"http://yoursite.com/tags/StickyListHeaders/"},{"name":"SwipeToLoadLayout","slug":"SwipeToLoadLayout","permalink":"http://yoursite.com/tags/SwipeToLoadLayout/"},{"name":"SwipeLayout","slug":"SwipeLayout","permalink":"http://yoursite.com/tags/SwipeLayout/"}]},{"title":"Android View的事件分发机制","slug":"Android View的事件分发机制","date":"2016-07-29T08:46:00.000Z","updated":"2016-08-02T03:03:46.000Z","comments":true,"path":"2016/07/29/Android View的事件分发机制/","link":"","permalink":"http://yoursite.com/2016/07/29/Android View的事件分发机制/","excerpt":"","text":"前言关于Android View事件分发机制的一个小结，基于他人分析以及个人理解，方便自己记录以及回忆，使用了一些UML图和流程图对部分流程进行了细化，并加入了自己的理解，期间参考了几篇比较优秀（不同博文可能针对的Android代码版本不同，存在些许出入，但是大致逻辑一致）的关于事件分发机制的博文，已在参考链接中列出。 该篇博文更适合那些对事件分发机制基本了解但是仍然缺少一个系统化轮廓的朋友，只是一个总结而非教程，如果完全没有概念的话先从参考链接的博文开始看起！然后再回过头来看这个总结。 如果发现有什么问题，欢迎留言拍砖！ Activity的事件分发逻辑 点击事件最先传递给当前的Activity，由Activity的dispatchToucnEvent来进行事件分发，具体的工作由Activity内部的Window来完成，Window会将事件传递给DecorView，DecorView一般就是当前界面的底层容器（即setContentView所设置的View的父容器），通过Activity.getWindow.getDecorView()可以获得 如果所有的View的onTouchEvent都返回了false，那么Activity的onTouchEvent就会被调用 Window的唯一实现是PhoneWindow PhoneWindow中通过DecorView往下分发事件 通过((ViewGroup))getWindow().getDecorView().findViewById(android.R.id.content).getChildAt(0)可以获得Activity所设置的View DecorView继承自FrameLayout且是父View，所以最终事件会传递给View ViewGroup以及View的事件分发逻辑 ViewGroup中的onInterceptTouchEvent用来控制ViewGroup是否拦截事件向下传递 ViewGroup的主要的任务是找一个Target，并且用这个target传递事件 在Down并且不拦截的时候会多出一个寻找Target的过程，在这个过程中遍历子View，如果子View的dispatchTouch为true（如果这里返回false的话，那么接下来的action就不会继续传递，因为这时的target就为空，target为空的话，就会触发ViewGroup作为一个View的dispatchTouchEvent()方法），则这个子View就是当前ViewGroup的Target。找Target是处理Down事件时候特有的，其他事件不会触发找Target。 那么上面说的View的dispatchTouchEvent一定会返回true吗？默认情况下只要View是Clickable或者LongClickable，就一定消费事件，即返回true 找到Target之后如果再次调用ViewGroup的dispatchTouchEvent，就用经过一系列逻辑判断继续调用Target的dispatchTouchEvent View的onTouchEvent中，当action == MotionEvent.ACTION_UP时，就会触发View的performClick()，所以onClick会晚于onTouch 总结和参考有没有发现，Android View的事件分发就是一个活生生的基于责任链模式实现的经典案例！ 建议：可以根据自己不同的理解程度参考如下博文：http://www.nowamagic.net/academy/detail/50160216http://blog.csdn.net/duo2005duo/article/details/51604119http://blog.csdn.net/guolin_blog/article/details/9153747《Android开发艺术探索》","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}]},{"title":"EventBus 更少的代码 更好的体验","slug":"EventBus 更少的代码 更好的体验","date":"2016-07-07T10:49:00.000Z","updated":"2017-08-04T06:06:42.000Z","comments":true,"path":"2016/07/07/EventBus 更少的代码 更好的体验/","link":"","permalink":"http://yoursite.com/2016/07/07/EventBus 更少的代码 更好的体验/","excerpt":"","text":"简介事件总线库，极大地简化了 Activities, Fragments, Threads, Services等各组件之间的通信。更少的代码，更好的体检EventBus的github地址 优点 简化组件之间的通信,对事件的发送者和接收者进行解耦;在Activity、Fragment、以及后台线程中运转良好;避免复杂和容易出错的依赖关系以及生命周期问题 使你的代码更简单，代码可读性更好 快 小（~ 50K的jar包） 在安装量多达100,000,000+ 的应用中实践，表现优异 独具特色的功能，如线程分发，优先级订阅等。 项目实战 需求背景 登录、登出成功之后，涉及的相关页面要即时刷新登录数据，做出相应的调整 多个页面涉及比赛预约的状态，一个页面预约或者取消预约成功，要即时更新其它页面的比赛预约状态 步骤部分概念相关的可以参考下面的相关介绍穿插理解 1、首先需要定义消息类，该类可以不继承任何基类也不需要实现任何接口 这里以LoginEvent（用户登录退出场景） 和AppointmentStateEvent （见注释）为例来介绍1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class OnEventBusInterface &#123; public interface OnLoginListener &#123; void onEventMainThread(LoginEvent event); &#125; public interface OnTopicRefreshListener &#123; void onEventMainThread(FollowTopicRefreshEvent event); &#125; public interface OnAppointmentStateListener &#123; void onEventMainThread(AppointmentStateEvent event); &#125; public static class LoginEvent &#123; private boolean hasLoginSucc; public LoginEvent(boolean loginSucc) &#123; this.hasLoginSucc = loginSucc; &#125; public boolean hasLoginSucc() &#123; return hasLoginSucc; &#125; public void setHasLoginSucc(boolean hasLoginSucc) &#123; this.hasLoginSucc = hasLoginSucc; &#125; &#125; //FollowFragment刷新事件 public static class FollowTopicRefreshEvent &#123; &#125; /** * 在比赛详情页 * 比赛未开始 * 从首页直播tab进入或者从球队详情页的比赛tab进入 * 在比赛未开始时，可以预约或者取消预约比赛，这个操作完成后再返回上面两个入口时，需要刷新预约状态 * 这里传入了matchId作为参数,目前没有用到，因为现在比赛的预约与否是存在本地数据库的 * 如果以后预约比赛的状态和用户绑定在服务器，那么可能就需要使用这个matchId了 * &lt;p/&gt; * 需要3个有关注状态的地方 互相通知最新的关注状态 * add By SuS */ public static class AppointmentStateEvent &#123; private String matchId; public AppointmentStateEvent(String matchId) &#123; this.matchId = matchId; &#125; public String getMatchId() &#123; return matchId; &#125; public void setMatchId(String matchId) &#123; this.matchId = matchId; &#125; &#125; 2、在需要订阅事件的地方注册事件，在需要取消消息订阅的地方取消消息订阅123456789101112131415161718192021222324252627public class BaseLoginActivity extends BaseActivity implements OnEventBusInterface.OnLoginListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); EventBus.getDefault().register(this);//注册EventBus &#125; @Override public void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this);//反注册EventBus &#125; protected void onLoginSuccess()&#123; &#125; protected void onLoginOut()&#123; &#125; public void onEventMainThread(OnEventBusInterface.LoginEvent event)&#123; if(event.hasLoginSucc())&#123; onLoginSuccess(); &#125;else&#123; onLoginOut(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class BaseLoginFragment extends BaseFragment implements IHandlerMessage,OnEventBusInterface.OnLoginListener,OnEventBusInterface.OnTopicRefreshListener,OnEventBusInterface.OnAppointmentStateListener &#123; protected Handler handler; @Override public void onViewCreated(View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); handler = new CommonHandler&lt;BaseLoginFragment&gt;(this); &#125; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); EventBus.getDefault().register(this);//注册EventBus &#125; @Override public void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this);//反注册EventBus &#125; @Override public void handlerCallback(Message msg) &#123; &#125; protected void showLoginWindow()&#123; StormUtils2.startLoginActivity(getActivity()); &#125; protected void onLoginSuccess()&#123; &#125; protected void onLoginOut()&#123; &#125; protected void onFollowStatusChanged() &#123;&#125; protected void onAppointmentStateChanged(String matchId)&#123; &#125; public void onEventMainThread(OnEventBusInterface.LoginEvent event)&#123; if(event.hasLoginSucc())&#123; onLoginSuccess(); &#125;else&#123; onLoginOut(); &#125; &#125; public void onEventMainThread(OnEventBusInterface.FollowTopicRefreshEvent event)&#123; onFollowStatusChanged(); &#125; @Override public void onEventMainThread(OnEventBusInterface.AppointmentStateEvent event) &#123; onAppointmentStateChanged(event.getMatchId()); &#125;&#125; 3、分发事件，即触发消息 这里对BaseActivity小做解释：当通过插件化的方式加载暴风体育的时候，启动登录，通过startActivityForResult的方式调用主版的登录（之所以调用主版的登录是因为主应用和以插件化方式加载的暴风体育第三方登录（QQ，微信）的签名不同），当登录成功获取用户信息后，分发用户登录成功的消息 代码很简洁，具体相关操作如下：1EventBus.getDefault().post(new OnEventBusInterface.LoginEvent(true));//登录成功 1EventBus.getDefault().post(new OnEventBusInterface.LoginEvent(false));//登出成功 1EventBus.getDefault().post(new OnEventBusInterface.AppointmentStateEvent(String.valueOf(matchInfo.getId())));//比赛预约状态改变成功 4、消息处理 这里使用了最普通的方式，没有使用EventBus的注解模式，而且考虑到收到消息后的处理都是在主线程中完成，所以采用了onEventMainThread方法。 继承了BaseLoginActivity的Activity的相关处理： 继承了BaseLoginFragment的Fragment的相关处理： 注意： 在3.0之前，EventBus还没有使用注解方式。消息处理的方法也只能限定于onEvent、onEventMainThread、onEventBackgroundThread和onEventAsync，分别代表四种线程模型。而在3.0之后，消息处理的方法可以随便取名，但是需要添加一个注解@Subscribe，并且要指定线程模型（默认为PostThread） 事件处理函数的访问权限必须为public，否则会报异常 相关代码如下：12345678910111213141516public void onEventMainThread(OnEventBusInterface.LoginEvent event)&#123; if(event.hasLoginSucc())&#123; onLoginSuccess(); &#125;else&#123; onLoginOut(); &#125; &#125; public void onEventMainThread(OnEventBusInterface.FollowTopicRefreshEvent event)&#123; onFollowStatusChanged(); &#125; @Override public void onEventMainThread(OnEventBusInterface.AppointmentStateEvent event) &#123; onAppointmentStateChanged(event.getMatchId()); &#125; ## 相关介绍### 线程模型主要包括如下四种：POSTING：&gt; 发布事件和接收事件在同一个线程&gt; 避免执行耗时操作，否则会阻塞事件的传递，有可能会引起ANR1234@Subscribe(threadMode = ThreadMode.POSTING) // ThreadMode is optional herepublic void onMessage(MessageEvent event) &#123; log(event.message);&#125;MAIN：&gt; 无论事件从哪里发布，接收事件都在UI线程&gt; 可以用来更新UI，但是不能处理耗时操作12345// Called in Android UI's main thread@Subscribe(threadMode = ThreadMode.MAIN)public void onMessage(MessageEvent event) &#123; textField.setText(event.message);&#125;BACKGROUND:&gt; 发布事件来自主线程，接收事件则在新的线程中运行；发布事件来自子线 程，接收事件也在该子线程完成&gt; 禁止进行UI更新操作12345// Called in the background thread@Subscribe(threadMode = ThreadMode.BACKGROUND)public void onMessage(MessageEvent event)&#123; saveToDisk(event.message);&#125;ASYNC：&gt; 无论事件从哪里发布，接收事件都在新的子线程&gt; 禁止进行UI更新操作12345// Called in a separate thread@Subscribe(threadMode = ThreadMode.ASYNC)public void onMessage(MessageEvent event)&#123; backend.send(event.message);&#125;### 订阅优先级以及事件取消尽管大多数情况下eventbus是不需要设置订阅的优先级和事件取消，但是某些特殊的场景可能派上用场。例如，当应用程序在前台，存在一个事件可能会触发一些用户界面相关逻辑，但当应用不可见时应该有不同的反应优先级设置:&gt; 默认优先级是0，同样的线程分发模式，优先级更高的订阅者会先收到消息&gt; 不同线程模式的订阅者接收消息的顺序呢不受优先级影响1234@Subscribe(priority = 1);public void onEvent(MessageEvent event) &#123;…&#125;事件取消：&gt; 事件取消一般都是被高优先级的订阅者调用&gt; 严格限制在线程模式为POSTING的消息处理方法中12345678// Called in the same thread (default)@Subscribepublic void onEvent(MessageEvent event)&#123;// Process the event…EventBus.getDefault().cancelEventDelivery(event) ;&#125;### 粘性事件EventBus还支持发送黏性事件，就是在发送事件之后再订阅该事件也能收到该事件，能够收到订阅之前发送的消息。但是它只能收到最新的一次消息。这里不做过多介绍，详情请参考Sticky Events## 总结&gt; 简单强大&gt; 实战验证&gt; 高性能&gt; 基于API的简洁注解&gt; 主线程和子线程均可进行消息发布和订阅&gt; 事件以及订阅者继承特点&gt;* 零配置且可配码字！排版！画图！终于写完了！","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"EventBus","slug":"EventBus","permalink":"http://yoursite.com/tags/EventBus/"},{"name":"事件总线库","slug":"事件总线库","permalink":"http://yoursite.com/tags/事件总线库/"}]},{"title":"Android自定义View之如期相遇的百分比进度条RatioProgress","slug":"Android自定义View之如期相遇的百分比进度条RatioProgress","date":"2016-05-27T02:34:00.000Z","updated":"2017-08-04T06:06:58.000Z","comments":true,"path":"2016/05/27/Android自定义View之如期相遇的百分比进度条RatioProgress/","link":"","permalink":"http://yoursite.com/2016/05/27/Android自定义View之如期相遇的百分比进度条RatioProgress/","excerpt":"","text":"需求简述：当进入比赛详情页面时，根据点赞数按比例分割整个屏幕宽度，这个过程以动态进度条的形式显示 实际应用效果图： Demo效果图： 分析自定义View的基本步骤： 自定义View的属性 在View的构造方法中获得我们自定义的属性 重写onMesure（非必须，大部分情况下需要） 重写onDraw 自定义View属性：在res/values/ 下建立一个attrs.xml ，在里面定义我们的属性和声明我们的整个样式，format是指该属性的取值类型 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"RatioProgress\"&gt; &lt;attr name=\"direction\" format=\"string\" /&gt; &lt;attr name=\"progressColor\" format=\"color\" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 这里，我根据需求定义了两个属性，分别为direction和progressColor direction表示进度条的绘制方向，有两个值，分别为“left”和“right” “left”表示从左到右进行显示,“right”表示从右向左进行显示 progressColor表示进度条的显示背景颜色 RatioProgress分析： 通过rectBgBounds 绘制背景矩形，进行占位，背景设置为透明的 通过rectProgressBounds来绘制进度条，背景颜色就是通过如下自定义属性进行设置 1sus:progressColor=\"@color/CommonTextSelect\" bgPaint和progressPaint分别为绘制背景和进度条的画笔 关键步骤之重写onDraw方法12345678910111213141516@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(rectBgBounds, bgPaint); if (TextUtils.equals(direction, \"left\")) &#123; rectProgressBounds = new RectF(0, 0, progress, layout_height); &#125; else if (TextUtils.equals(direction, \"right\")) &#123; rectProgressBounds = new RectF(getWidth() - progress, 0, getWidth(), layout_height); &#125;else&#123; rectProgressBounds = new RectF(0, 0, progress, layout_height); &#125; canvas.drawRect(rectProgressBounds, progressPaint);&#125;&gt; 这里根据direction属性来设置rectProgressBounds 的坐标位置&gt; 我在 setupBounds()中通过start方法开启一个线程12345678910111213141516171819202122232425final Runnable r = new Runnable() &#123; public void run() &#123; running = true; Log.e(\"thread\", \"progress=\"+progress); Log.e(\"thread\", \"getWidth()=\"+getWidth()); while (progress &lt; getWidth()) &#123; incrementProgress(); //progress++; try &#123; Thread.sleep(sleepDelay); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; running = false; &#125;&#125;;public void start()&#123; if (!running) &#123; progress = 0; Thread s = new Thread(r); s.start(); &#125;&#125;&gt;* 并通过incrementProgress方法递增progress，然后再通过handler发消息不断进行绘制1234567891011/** * Increment the progress by 1 (of 100) */ public void incrementProgress() &#123; isProgress = true; progress++; /* * if (progress &gt; 200) progress = 100; */ spinHandler.sendEmptyMessage(0); &#125;RatioProgress 完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216public class RatioProgress extends View &#123; // Sizes (with defaults) private int layout_height = 0; private int layout_width = 0; // Colors (with defaults) private int bgColor = Color.TRANSPARENT; //private int progressColor = 0xFF339933; // Paints private Paint progressPaint = new Paint(); private Paint bgPaint = new Paint(); // Rectangles private RectF rectBgBounds = new RectF(); private RectF rectProgressBounds = new RectF(); int progress = 0; boolean isProgress; private String direction; /** * progress的颜色 */ private int progressColor; boolean running; int sleepDelay; public int getSleepDelay() &#123; return sleepDelay; &#125; public void setSleepDelay(int sleepDelay) &#123; this.sleepDelay = sleepDelay; &#125; private Handler spinHandler = new Handler() &#123; /** * This is the code that will increment the progress variable and so * spin the wheel */ @Override public void handleMessage(Message msg) &#123; invalidate(); &#125; &#125;; /** * @param context */ public RatioProgress(Context context) &#123; this(context, null); &#125; /** * @param context * @param attrs */ public RatioProgress(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; /** * @param context * @param attrs * @param defStyleAttr */ public RatioProgress(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); /** * 获得我们所定义的自定义样式属性 */ TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.RatioProgress, defStyleAttr, 0); int n = a.getIndexCount(); for (int i = 0; i &lt; n; i++) &#123; int attr = a.getIndex(i); switch (attr) &#123; case R.styleable.RatioProgress_direction: direction = a.getString(attr); Log.e(\"direction-----------------\", direction); break; case R.styleable.RatioProgress_progressColor: progressColor = a.getColor(attr, Color.TRANSPARENT); break; &#125; &#125; a.recycle(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); // Share the dimensions layout_width = w; Log.i(\"layout_width\", layout_width + \"\"); layout_height = h; Log.i(\"layout_height\", layout_height + \"\"); setupBounds(); setupPaints(); invalidate(); &#125; private void setupPaints() &#123; bgPaint.setColor(bgColor); bgPaint.setAntiAlias(true); bgPaint.setStyle(Style.FILL); progressPaint.setColor(progressColor); progressPaint.setAntiAlias(true); progressPaint.setStyle(Style.FILL); &#125; private void setupBounds() &#123; int width = getWidth(); // this.getLayoutParams().width; Log.i(\"width\", width + \"\"); int height = getHeight(); // this.getLayoutParams().height; Log.i(\"height\", height + \"\"); rectBgBounds = new RectF(0, 0, width, height); start(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(rectBgBounds, bgPaint); Log.i(\"progress\", progress + \"\"); if (TextUtils.equals(direction, \"left\")) &#123; rectProgressBounds = new RectF(0, 0, progress, layout_height); &#125; else if (TextUtils.equals(direction, \"right\")) &#123; rectProgressBounds = new RectF(getWidth() - progress, 0, getWidth(), layout_height); &#125;else&#123; rectProgressBounds = new RectF(0, 0, progress, layout_height); &#125; canvas.drawRect(rectProgressBounds, progressPaint); &#125; /** * Increment the progress by 1 (of 100) */ public void incrementProgress() &#123; isProgress = true; progress++; /* * if (progress &gt; 200) progress = 100; */ spinHandler.sendEmptyMessage(0); &#125; /** * Increment the progress by 1 (of 100) */ public void unIncrementProgress() &#123; isProgress = true; progress--; /* * if (progress &lt; 1) progress = 100; */ spinHandler.sendEmptyMessage(0); &#125; /** * Set the progress to a specific value */ public void setProgress(int i) &#123; progress = i; spinHandler.sendEmptyMessage(0); &#125; final Runnable r = new Runnable() &#123; public void run() &#123; running = true; Log.e(\"thread\", \"progress=\"+progress); Log.e(\"thread\", \"getWidth()=\"+getWidth()); while (progress &lt; getWidth()) &#123; incrementProgress(); //progress++; try &#123; Thread.sleep(sleepDelay); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; running = false; &#125; &#125;; public void start()&#123; if (!running) &#123; progress = 0; Thread s = new Thread(r); s.start(); &#125; &#125;&#125;## 布局以及代码中的使用：### 布局文件 这里在LinearLayout 中定义了两个RatioProgress1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:sus=\"http://schemas.android.com/apk/res/com.soulrelay.ratioprogress\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\" &gt; &lt;com.soulrelay.ratioprogress.RatioProgress android:id=\"@+id/left_ratio_progress\" android:layout_width=\"match_parent\" android:layout_height=\"4dp\" android:layout_marginTop=\"100dp\" sus:direction=\"left\" sus:progressColor=\"@color/CommonTextSelect\" /&gt; &lt;com.soulrelay.ratioprogress.RatioProgress android:id=\"@+id/right_ratio_progress\" android:layout_width=\"match_parent\" android:layout_height=\"4dp\" android:layout_marginLeft=\"4dp\" android:layout_marginTop=\"100dp\" sus:direction=\"right\" sus:progressColor=\"@color/CommonSelect\"/&gt;&lt;/LinearLayout&gt; 实际java代码中的控制这里主要是设置leftRatioProgress和rightRatioProgress的宽度，以及通过设置View中的线程休眠时间来控制进度条可以同时相遇1234567891011121314151617181920212223242526272829303132public class MainActivity extends Activity &#123; RatioProgress leftRatioProgress; RatioProgress rightRatioProgress; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); WindowManager manager = ((WindowManager) this .getSystemService(Context.WINDOW_SERVICE)); DisplayMetrics dm = new DisplayMetrics(); manager.getDefaultDisplay().getMetrics(dm); final int w = dm.widthPixels; leftRatioProgress = (RatioProgress) findViewById(R.id.left_ratio_progress); LayoutParams lp = leftRatioProgress.getLayoutParams(); lp.width = w/3; leftRatioProgress.setLayoutParams(lp); rightRatioProgress = (RatioProgress) findViewById(R.id.right_ratio_progress); LayoutParams lp1 = rightRatioProgress.getLayoutParams(); lp1.width = w*2/3; rightRatioProgress.setLayoutParams(lp1); leftRatioProgress.setSleepDelay(6); rightRatioProgress.setSleepDelay(3); &#125;&#125; 实际代码中我是根据用户的点赞数来分割屏幕宽度，设置View中的休眠时间 以下代码仅供参考：12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 进度条形式显示赞数的比例 * * @param matchInfo * @author sushuai */ private void initRatioProgress(MatchInfo matchInfo) &#123; int width = SystemUtil.getScreenDisplayMinWidth(context); int leftWeight = matchInfo.getTeam1().getLikes(); int rightWeight = matchInfo.getTeam2().getLikes(); int leftWidth = 0, rightWidth = 0; if (leftWeight == 0 &amp;&amp; rightWeight == 0) &#123; leftWidth = rightWidth = width / 2; &#125; else if (leftWeight == 0) &#123; rightWidth = width; &#125; else if (rightWeight == 0) &#123; leftWidth = width; &#125; else &#123; leftWidth = width * leftWeight / (leftWeight + rightWeight); rightWidth = width * rightWeight / (leftWeight + rightWeight); &#125; if (leftRatioProgress != null) &#123; LayoutParams lp = leftRatioProgress.getLayoutParams(); lp.width = leftWidth; leftRatioProgress.setLayoutParams(lp); if (leftWidth &gt;= rightWidth) &#123; leftRatioProgress.setSleepDelay(1); &#125; else if (leftWidth != 0) &#123; leftRatioProgress.setSleepDelay(rightWidth / leftWidth); &#125; &#125; if (rightRatioProgress != null) &#123; LayoutParams lp = rightRatioProgress.getLayoutParams(); lp.width = rightWidth; rightRatioProgress.setLayoutParams(lp); if (leftWidth &gt;= rightWidth &amp;&amp; rightWidth != 0) &#123; rightRatioProgress.setSleepDelay(leftWidth / rightWidth); &#125; else &#123; rightRatioProgress.setSleepDelay(1); &#125; &#125; &#125; 其它Demo下载：传送门 参考链接：1、http://blog.csdn.net/wangjinyu501/article/details/382987371、http://blog.csdn.net/lmj623565791/article/details/24252901/","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}]},{"title":"Android-architecture之MVC、MVP、MVVM、Data-Binding","slug":"Android-architecture之MVC、MVP、MVVM、Data-Binding","date":"2016-05-27T02:29:00.000Z","updated":"2017-08-04T06:16:48.000Z","comments":true,"path":"2016/05/27/Android-architecture之MVC、MVP、MVVM、Data-Binding/","link":"","permalink":"http://yoursite.com/2016/05/27/Android-architecture之MVC、MVP、MVVM、Data-Binding/","excerpt":"","text":"传送门这里是之前分享的关于Android架构的一篇ppt，可以作为简要的参考Android Architecture（Is Activity God？） MVC结构简介各个模块的关系以及功能 实例分析 Controller控制器式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class MainActivity extends ActionBarActivity implements OnWeatherListener, View.OnClickListener &#123; private WeatherModel weatherModel; private Dialog loadingDialog; private EditText cityNOInput; private TextView city; private TextView cityNO; private TextView temp; private TextView wd; private TextView ws; private TextView sd; private TextView wse; private TextView time; private TextView njd; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); weatherModel = new WeatherModelImpl(); initView(); &#125; /** * 初始化View */ private void initView() &#123; cityNOInput = findView(R.id.et_city_no); city = findView(R.id.tv_city); cityNO = findView(R.id.tv_city_no); temp = findView(R.id.tv_temp); wd = findView(R.id.tv_WD); ws = findView(R.id.tv_WS); sd = findView(R.id.tv_SD); wse = findView(R.id.tv_WSE); time = findView(R.id.tv_time); njd = findView(R.id.tv_njd); findView(R.id.btn_go).setOnClickListener(this); loadingDialog = new ProgressDialog(this); loadingDialog.setTitle(加载天气中...); &#125; /** * 显示结果 * * @param weather */ public void displayResult(Weather weather) &#123; WeatherInfo weatherInfo = weather.getWeatherinfo(); city.setText(weatherInfo.getCity()); cityNO.setText(weatherInfo.getCityid()); temp.setText(weatherInfo.getTemp()); wd.setText(weatherInfo.getWD()); ws.setText(weatherInfo.getWS()); sd.setText(weatherInfo.getSD()); wse.setText(weatherInfo.getWSE()); time.setText(weatherInfo.getTime()); njd.setText(weatherInfo.getNjd()); &#125; /** * 隐藏进度对话框 */ public void hideLoadingDialog() &#123; loadingDialog.dismiss(); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_go: loadingDialog.show(); weatherModel.getWeather(cityNOInput.getText().toString().trim(), this); break; &#125; &#125; @Override public void onSuccess(Weather weather) &#123; hideLoadingDialog(); displayResult(weather); &#125; @Override public void onError() &#123; hideLoadingDialog(); Toast.makeText(this, 获取天气信息失败, Toast.LENGTH_SHORT).show(); &#125; private T findView(int id) &#123; return (T) findViewById(id); &#125;&#125; Model模型123public interface WeatherModel &#123; void getWeather(String cityNumber, OnWeatherListener listener);&#125;1234567891011121314151617181920212223public class WeatherModelImpl implements WeatherModel &#123; @Override public void getWeather(String cityNumber, final OnWeatherListener listener) &#123; /*数据层操作*/ VolleyRequest.newInstance().newGsonRequest(http://www.weather.com.cn/data/sk/ + cityNumber + .html, Weather.class, new Response.Listener() &#123; @Override public void onResponse(Weather weather) &#123; if (weather != null) &#123; listener.onSuccess(weather); &#125; else &#123; listener.onError(); &#125; &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; listener.onError(); &#125; &#125;); &#125;## 总结&gt; 扩展性好、维护性、模块职责明确&gt; 耦合性低（解耦）、V和M非真正意义上的分离什么时候适合使用MVC设计模式？ 当一个小的项目且无需频繁修改需求就不用MVC框架来设计了，那样反而觉得代码过度设计，代码臃肿。一般在大的项目中，且业务逻辑处理复杂，页面显示比较多，需要模块化设计的项目使用MVC就有足够的优势了。 MVP结构简介 为什么使用MVP模式在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户界面，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升，Activity类的职责不断增加，以致变得庞大臃肿。当我们将其中复杂的逻辑处理移至另外的一个类（Presneter）中时，Activity其实就是MVP模式中View，它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由Presenter处理）. 另外，回想一下你在开发Android应用时是如何对代码逻辑进行单元测试的？是否每次都要将应用部署到Android模拟器或真机上，然后通过模拟用户操作进行测试？然而由于Android平台的特性，每次部署都耗费了大量的时间，这直接导致开发效率的降低。而在MVP模式中，处理复杂逻辑的Presenter是通过interface与View(Activity)进行交互的，这说明了什么？说明我们可以通过自定义类实现这个interface来模拟Activity的行为对Presenter进行单元测试，省去了大量的部署及测试的时间。 实例分析MVP模式 View与Model并不直接交互，而是使用Presenter作为View与Model之间的桥梁。其中Presenter中同时持有Viwe层以及Model层的Interface的引用，而View层持有Presenter层Interface的引用。当View层某个界面需要展示某些数据的时候，首先会调用Presenter层的某个接口，然后Presenter层会调用Model层请求数据，当Model层数据加载成功之后会调用Presenter层的回调方法通知Presenter层数据加载完毕，最后Presenter层再调用View层的接口将加载后的数据展示给用户。这就是MVP模式的整个核心过程。 官方模式图 android-architecture官方传送门 案例 这里以暴风体育中的话题列表为例来进行介绍： TopicModel 123456789101112131415161718192021222324252627282930313233343536public interface TopicModel &#123; /** * 加载话题列表首页数据 * * @param context * @param listener */ void loadTopicList(Context context, TopicModelImpl.OnLoadTopicListListener listener); /** * 从本地数据库中获取我关注的话题数据 * * @param context * @param listener * @return */ ArrayList&lt;TopicItem&gt; loadFollowTopic(Context context, TopicModelImpl.OnLoadTopicListListener listener); /** * 全部话题加载更多数据 * * @param context * @param paramMap * @param listener */ void loadMoreAllTopic(Context context, Map&lt;String, String&gt; paramMap, TopicModelImpl.OnLoadTopicListListener listener); /** * 更新我关注的话题的最新帖子数和帖子最近的更新时间 * * @param context * @param threadItem * @param listener */ void updateThreadItem(final Context context, ThreadItem threadItem, TopicModelImpl.OnLoadTopicListListener listener);&#125; TopicPresenter 123456789101112131415161718192021222324public interface TopicPresenter &#123; /** * 加载话题列表首页数据 * * @param context */ void loadTopicList(Context context); /** * 全部话题加载更多数据 * * @param context * @param paramMap */ void loadMoreAllTopic(Context context, Map&lt;String, String&gt; paramMap); /** * * @param context * @return */ ArrayList&lt;TopicItem&gt; loadFollowTopic(Context context);&#125; TopicView 12345678910111213141516public interface TopicView &#123; void showProgress(); void addTopics(List&lt;TopicItem&gt; topicList); void addSwipeUpItem(SwipeUpItem item); void addLoadMoreTopics(List&lt;TopicItem&gt; topicList); void hideProgress(); void showLoadFailMsg(); //二次请求需要重新刷新界面 void notifyAdapter();&#125; TopicModelImpl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160/** * DES： * Created by sushuai on 2016/4/13. */public class TopicModelImpl implements TopicModel &#123; private static final String TAG = \"TopicModelImpl\"; /** * 加载话题列表首页数据 * * @param context * @param listener */ @Override public void loadTopicList(final Context context, final OnLoadTopicListListener listener) &#123; AsyncHttpRequest.doASynGetRequest(context, UrlContainer.HOME_TOPIC, null, true, new AsyncHttpRequest.CallBack() &#123; @Override public void fail(String ret) &#123; listener.onFailure(Net.ErrorNo.NO_DATA); &#125; @Override public void call(String data) &#123; try &#123; ArrayList&lt;TopicItem&gt; items = (ArrayList&lt;TopicItem&gt;) TopicListDataParseUtils.readJsonTopicLists(data, listener); //items.addAll(0, loadFollowTopic(context, listener)); if (items != null) &#123; listener.onSuccess(items); &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); listener.onFailure(Net.ErrorNo.ERROR_JSON); &#125; &#125; &#125;); &#125; /** * 从本地数据库中获取我关注的话题数据 * * @param context * @param listener * @return */ @Override public ArrayList&lt;TopicItem&gt; loadFollowTopic(Context context, final OnLoadTopicListListener listener) &#123; ArrayList&lt;TopicItem&gt; items = new ArrayList&lt;&gt;(); ArrayList&lt;ThreadItem&gt; ThreadItems = (ArrayList&lt;ThreadItem&gt;) FollowTopicDao.getInstance(context).getLatest3Topics(); if (ThreadItems.size() &lt;= 0) &#123; return items; &#125; for (int i = 0; i &lt; ThreadItems.size(); i++) &#123; ThreadItem threadItem = ThreadItems.get(i); updateThreadItem(context, threadItem, listener); &#125; TopicItem meItem = new TopicItem(); meItem.setType(TopicAdapter.TYPE_TOPIC_TITLE_ME); items.add(meItem); for (int i = 0; i &lt; ThreadItems.size(); i++) &#123; TopicItem topicItem = new TopicItem(); topicItem.setType(TopicAdapter.TYPE_TOPIC_THREAD); topicItem.setOther(ThreadItems.get(i)); items.add(topicItem); &#125; return items; &#125; /** * 更新我关注的话题的最新帖子数和帖子最近的更新时间 * * @param context * @param threadItem * @param listener */ @Override public void updateThreadItem(final Context context, final ThreadItem threadItem, final OnLoadTopicListListener listener) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(Net.Field.id, String.valueOf(threadItem.getId())); final int prePosts = threadItem.getCount(); AsyncHttpRequest.doASynGetRequest(context, UrlContainer.GET_TOPIC_POSTS, (HashMap&lt;String, String&gt;) map, true, new AsyncHttpRequest.CallBack() &#123; @Override public void fail(String ret) &#123; &#125; @Override public void call(String data) &#123; try &#123; JSONObject jo = new JSONObject(data); int errno = DataParseUtils.getJsonInt(jo, Net.Field.errno); if (errno == Net.ErrorNo.SUCCESS) &#123; JSONObject jsonObj = DataParseUtils.getJsonObj(jo, Net.Field.data); int count = DataParseUtils.getJsonInt(jsonObj, Net.Field.count); long latest_update_tm = DataParseUtils.getJsonLong(jsonObj, Net.Field.latest_update_tm); threadItem.setUpdateCount(count - prePosts); threadItem.setCount(count); threadItem.setUpdateTime(latest_update_tm); FollowTopicDao.getInstance(context).updatePostsById(threadItem.getId(), count); listener.onUpdateThreadItem(); &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; /** * 全部话题加载更多数据 * * @param context * @param paramMap * @param listener */ @Override public void loadMoreAllTopic(Context context, Map&lt;String, String&gt; paramMap, final OnLoadTopicListListener listener) &#123; AsyncHttpRequest.doASynGetRequest(context, UrlContainer.TOPIC_LIST, (HashMap&lt;String, String&gt;) paramMap, true, new AsyncHttpRequest.CallBack() &#123; @Override public void fail(String ret) &#123; listener.onFailure(Net.ErrorNo.NO_DATA); &#125; @Override public void call(String data) &#123; try &#123; ArrayList&lt;TopicItem&gt; items = (ArrayList&lt;TopicItem&gt;) TopicListDataParseUtils.readMoreAllTopic(data, listener); if (items != null) &#123; listener.onLoadMoreAllTopics(items); &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); listener.onFailure(Net.ErrorNo.ERROR_JSON); &#125; &#125; &#125;); &#125; public interface OnLoadTopicListListener &#123; //加载话题列表首页数据成功 void onSuccess(List&lt;TopicItem&gt; list); //加载话题列表首页数据失败 void onFailure(int erroNo); //全部话题加载更多相关配置 void onLoadMoreSwipeUp(SwipeUpItem item); //回去加载更多数据 void onLoadMoreAllTopics(List&lt;TopicItem&gt; list); //更新我关注的话题的相关数据 void onUpdateThreadItem(); &#125;&#125;TopicPresenterImpl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * DES： * Created by sushuai on 2016/4/13. */public class TopicPresenterImpl implements TopicPresenter, TopicModelImpl.OnLoadTopicListListener &#123; private static final String TAG = \"TopicPresenterImpl\"; private TopicModel mTopicModel; private TopicView mTopicView; public TopicPresenterImpl(TopicView topicView) &#123; this.mTopicModel = new TopicModelImpl(); this.mTopicView = topicView; &#125; @Override public void loadTopicList(Context context) &#123; mTopicModel.loadTopicList(context, this); &#125; @Override public void loadMoreAllTopic(Context context, Map&lt;String, String&gt; paramMap) &#123; mTopicModel.loadMoreAllTopic(context, paramMap, this); &#125; @Override public ArrayList&lt;TopicItem&gt; loadFollowTopic(Context context) &#123; return mTopicModel.loadFollowTopic(context,this); &#125; @Override public void onSuccess(List&lt;TopicItem&gt; list) &#123; mTopicView.hideProgress(); mTopicView.addTopics(list); &#125; @Override public void onFailure(int erroNo) &#123; mTopicView.hideProgress(); mTopicView.showLoadFailMsg(); &#125; @Override public void onLoadMoreSwipeUp(SwipeUpItem item) &#123; mTopicView.addSwipeUpItem(item); &#125; @Override public void onLoadMoreAllTopics(List&lt;TopicItem&gt; list) &#123; mTopicView.addLoadMoreTopics(list); &#125; @Override public void onUpdateThreadItem() &#123; mTopicView.notifyAdapter(); &#125;&#125;TabTopicFragment123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340/** * 话题 * SuShuai * 2016/4/12 14:39 */public class TabTopicFragment extends BaseFragment implements TopicAdapter.AdapterCallback, TopicView, IHandlerMessage, XListView.IXListViewListener &#123; // TODO: Rename parameter arguments, choose names that match // the fragment initialization parameters, e.g. ARG_ITEM_NUMBER private static final String TAG = \"TabTopicFragment\"; private static final String ARG_PARAM1 = \"param1\"; private static final String ARG_PARAM2 = \"param2\"; // TODO: Rename and change types of parameters private String mParam1; private String mParam2; private XListView listView; private TopicAdapter topicAdapter; private ArrayList&lt;TopicItem&gt; topicList = new ArrayList&lt;&gt;(); private ArrayList&lt;TopicItem&gt; homeList = new ArrayList&lt;&gt;(); private ArrayList&lt;TopicItem&gt; followTopicList = new ArrayList&lt;&gt;(); private TopicPresenter mTopicPresenter; private CommonHandler&lt;TabTopicFragment&gt; handler; private SwipeUpItem swipeUpItem; private View rootView; private String after = \"\"; public TabTopicFragment() &#123; // Required empty public constructor &#125; /** * Use this factory method to create a new instance of * this fragment using the provided parameters. * * @param param1 Parameter 1. * @param param2 Parameter 2. * @return A new instance of fragment TabTopicFragment. */ // TODO: Rename and change types and number of parameters public static TabTopicFragment newInstance(String param1, String param2) &#123; TabTopicFragment fragment = new TabTopicFragment(); Bundle args = new Bundle(); args.putString(ARG_PARAM1, param1); args.putString(ARG_PARAM2, param2); fragment.setArguments(args); return fragment; &#125; @Override public void onAttach(Context context) &#123; super.onAttach(context); LogHelper.e(TAG, \"SuS--&gt; onAttach: \"); &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (getArguments() != null) &#123; mParam1 = getArguments().getString(ARG_PARAM1); mParam2 = getArguments().getString(ARG_PARAM2); &#125; mTopicPresenter = new TopicPresenterImpl(this); LogHelper.e(TAG, \"SuS--&gt; onCreate: \"); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; LogHelper.e(TAG, \"whb--&gt; onCreateView: \"); if (rootView == null) &#123; rootView = inflater.inflate(R.layout.fragment_tab_topic, container, false); initViews(rootView); &#125; return rootView; &#125; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; LogHelper.e(TAG, \"SuS--&gt; onActivityCreated: \"); super.onActivityCreated(savedInstanceState); initData(); &#125; private void initData() &#123; handler = new CommonHandler&lt;TabTopicFragment&gt;(this); topicAdapter = new TopicAdapter(getActivity(), this); listView.setAdapter(topicAdapter); if (NetUtils.isNetworkAvaliable(getActivity())) &#123; showLoadingView(); mTopicPresenter.loadTopicList(getActivity()); followTopicList = mTopicPresenter.loadFollowTopic(getActivity()); &#125; else &#123; if (topicList.size() &gt; 0) &#123; topicAdapter.update(topicList); ToastUtils.toast(getActivity(), \"没有网络\"); listView.restListView(); return; &#125; showNetErroView(R.string.tips_net_error); &#125; &#125; private void initViews(View v) &#123; setImmerseLayout(v.findViewById(R.id.common_back)); setTitleBar(v, R.string.tab_topic); setLeftGone(v); listView = (XListView) v.findViewById(R.id.lv_topic); listView.setPullRefreshEnable(true); listView.setPullLoadEnable(true); listView.setAutoLoadEnable(true); listView.setXListViewListener(this); &#125; @Override public void onAdapterCallback(int eventId, Object obj) &#123; if (isAdded()) &#123; BaofengStatistics.onUmengEvent(getActivity(), BfCountConst.TopicConst.BBS_MOREFOLLOW_CLICK); LogHelper.v(\"umeng\", \"bbs_morefollow_click 计数一次\"); &#125; ActivityUtil.startActivity(getActivity(), MoreFollowTopicActivity.class, null, false); &#125; @Override public void showProgress() &#123; &#125; @Override public void addTopics(List&lt;TopicItem&gt; topicList) &#123; handler.obtainMessage(HandlerMsg.MSG_LOAD_TOPIC_LIST_SUC, topicList).sendToTarget(); &#125; @Override public void addSwipeUpItem(SwipeUpItem item) &#123; if (item == null) &#123; return; &#125; handler.obtainMessage(HandlerMsg.MSG_LOAD_SWIPE_UP_ITEM, item).sendToTarget(); &#125; @Override public void addLoadMoreTopics(List&lt;TopicItem&gt; topicList) &#123; handler.obtainMessage(HandlerMsg.MSG_LOAD_MORE_TOPICS, topicList).sendToTarget(); &#125; @Override public void hideProgress() &#123; // handler.obtainMessage(HandlerMsg.MSG_DISMISS_LOADING).sendToTarget(); &#125; @Override public void showLoadFailMsg() &#123; if (topicList == null || topicList.size() == 0) &#123; handler.obtainMessage(HandlerMsg.MSG_SHOW_EMPTY_CONTENT).sendToTarget(); &#125;else &#123; handler.obtainMessage(HandlerMsg.MSG_SHOW_FAIL).sendToTarget(); &#125; &#125; @Override public void notifyAdapter() &#123; handler.obtainMessage(HandlerMsg.MSG_NOTIFY_ADAPTER_CONTENT).sendToTarget(); &#125; @Override public void handlerCallback(Message msg) &#123; switch (msg.what) &#123; case HandlerMsg.MSG_LOAD_TOPIC_LIST_SUC: dealTopicListSuc(msg); break; case HandlerMsg.MSG_LOAD_SWIPE_UP_ITEM: SwipeUpItem item = (SwipeUpItem) msg.obj; this.swipeUpItem = item; break; case HandlerMsg.MSG_LOAD_MORE_TOPICS: dealLoadMoreTopics(msg); break; case HandlerMsg.MSG_DISMISS_LOADING: dismissLoadingView(); break; case HandlerMsg.MSG_SHOW_EMPTY_CONTENT: showContentEmptyView(); break; case HandlerMsg.MSG_NOTIFY_ADAPTER_CONTENT: topicAdapter.notifyDataSetChanged(); break; case HandlerMsg.MSG_SHOW_FAIL: ToastUtils.toast(getActivity(),R.string.error_no); break; default: break; &#125; &#125; private void dealLoadMoreTopics(Message msg) &#123; List&lt;TopicItem&gt; moreList = (List&lt;TopicItem&gt;) msg.obj; int count1 = listView.getLastVisiblePosition(); int count2 = topicAdapter.getCount()-1+2; if (moreList.size() &lt; swipeUpItem.getLimit() &amp;&amp; count1 == count2) &#123; ToastUtils.toast(getActivity(), \"已到达底部\"); &#125; if (moreList.size() &gt; 0) &#123; after = TabTopicUtil.getLastKey(moreList); &#125; TabTopicUtil.filterDuplicatedTopic(moreList,homeList); this.topicList.addAll(moreList); topicAdapter.update(this.topicList); listView.restListView(); &#125; private void dealTopicListSuc(Message msg) &#123; List&lt;TopicItem&gt; topicList = (List&lt;TopicItem&gt;) msg.obj; if (topicList.size() &lt;= 0) &#123; showContentEmptyView(); return; &#125; after = TabTopicUtil.getLastKey(topicList); TabTopicUtil.removeDuplicateWithOrder(topicList); topicList.addAll(0,followTopicList); this.topicList = (ArrayList&lt;TopicItem&gt;) topicList; this.homeList = (ArrayList&lt;TopicItem&gt;) topicList; topicAdapter.update(topicList); dismissLoadingView(); listView.restListView(); &#125; @Override public void onRefresh() &#123; //handler.postDelayed(new Runnable() &#123; // @Override //public void run() &#123; if (NetUtils.isNetworkAvaliable(getActivity())) &#123; mTopicPresenter.loadTopicList(getActivity()); &#125; else &#123; if (topicList.size() &gt; 0) &#123; ToastUtils.toast(getActivity(), \"没有网络\"); listView.restListView(); return; &#125; showNetErroView(R.string.tips_net_error); &#125; // &#125; //&#125;, 2000); &#125; @Override public void onLoadMore() &#123; handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; Map&lt;String, String&gt; m = new HashMap&lt;&gt;(); int size = topicList.size(); if (size &lt;= 0) return; m.put(Net.Param.ID, String.valueOf(swipeUpItem.getId())); m.put(Net.Param.AFTER, after); m.put(Net.Param.LIMIT, String.valueOf(swipeUpItem.getLimit())); if (NetUtils.isNetworkAvaliable(getActivity())) &#123; mTopicPresenter.loadMoreAllTopic(getActivity(), m); &#125; else &#123; ToastUtils.toast(getActivity(), \"没有网络\"); listView.restListView(); &#125; &#125; &#125;, 500); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.fragment_net_error_subTree: reQuestData(); break; default: break; &#125; &#125; /** * 重新请求数据 */ private void reQuestData() &#123; dismissNetErroView(); dismissContentEmptyView(); if (NetUtils.isNetworkAvaliable(getActivity())) &#123; showLoadingView(); mTopicPresenter.loadTopicList(getActivity()); &#125; else &#123; showNetErroView(R.string.tips_net_error); &#125; &#125; public interface HandlerMsg &#123; //获取话题列表成功 int MSG_LOAD_TOPIC_LIST_SUC = 2002; //获取加载更多配置选项 int MSG_LOAD_SWIPE_UP_ITEM = 2003; //加载更多话题 int MSG_LOAD_MORE_TOPICS = 2004; //隐藏loading int MSG_DISMISS_LOADING = 2005; //显示空 int MSG_SHOW_EMPTY_CONTENT = 2006; //二次请求刷新界面 int MSG_NOTIFY_ADAPTER_CONTENT = 2007; //显示失败 int MSG_SHOW_FAIL = 2008; &#125; @Override public void onDestroyView() &#123;// unbindDrawables(getView()); LogHelper.e(TAG, \"whb--&gt; onDestroyView: \"); super.onDestroyView(); &#125; @Override public void onResume() &#123; super.onResume(); LogHelper.d(TAG, \"SuS--&gt; onResume: \"); BaofengStatistics.onUmengEvent(getActivity(), BfCountConst.TopicConst.BBS_CHANNELLIST_SHOW); LogHelper.v(\"umeng\", \"bbs_channelList_show 计数一次\"); topicList.removeAll(followTopicList); followTopicList = mTopicPresenter.loadFollowTopic(getActivity()); topicList.addAll(0,followTopicList); topicAdapter.notifyDataSetChanged(); //initData(); &#125;&#125;## MVP与MVC的异同 MVC模式与MVP模式都作为用来分离UI层与业务层的一种开发模式被应用了很多年。在我们选择一种开发模式时，首先需要了解一下这种模式的利弊： 无论MVC或是MVP模式都不可避免地存如下弊端，这就导致了这两种开发模式也许并不是很小型应用。 &gt; 额外的代码复杂度和学习成本但比起他们的优点，这点弊端基本可以忽略了： &gt; 降低耦合度 &gt; 模块职责划分明显 &gt; 利于测试驱动开发 &gt; 代码复用 &gt; 隐藏数据 &gt; 代码灵活性 对于MVP与MVC这两种模式，它们之间也有很大的差异。以下是这两种模式之间最关键的差异： MVP模式：&gt; View不直接与Model交互，而是通过与Presenter交互来与Model间接交互&gt; Presenter与View的交互是通过接口来进行的，更有利于添加单元测试&gt; 通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑MVC模式：&gt; View可以与Model直接交互&gt; Controller是基于行为的，并且可以被多个View共享&gt;* 可以负责决定显示哪个View# MVVM# Data-Binding## 前言 第三方的数据绑定框架随时有停止更新的风险，官方的则相对更稳定一些 大量的findViewById，增加代码的耦合性 虽然可以通过注解框架抛弃大量的findViewById，但是注解注定要拖慢我们代码的速度，Data Binding则不会，官网文档说还会提高解析XML的速度 这里不赘述了，下面几篇文章都讲的很详细！ 精通 Android Data Binding Android官方数据绑定框架DataBinding(一) Android官方数据绑定框架DataBinding(二)官方Data Binding Library 参考链接：1、https://www.zhihu.com/question/214066852、http://liuling123.com/2015/12/mvp-pattern-android.html3、http://www.2cto.com/kf/201506/405766.html4、http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0313/2599.html5、http://blog.csdn.net/qibin0506/article/details/473937256、http://zjutkz.net/2016/04/13/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC%EF%BC%8CMVP%E5%92%8CMVVM/#plg_nld=1&amp;plg_auth=1&amp;plg_nld=1&amp;plg_dev=1&amp;plg_uin=1&amp;plg_usr=1&amp;plg_vkey=1&amp;plg_nld=1&amp;more?hmsr=toutiao.io&amp;utm_source=toutiao.io&amp;plg_uin=1&amp;plg_auth=1&amp;utm_medium=toutiao.io&amp;plg_dev=1&amp;plg_nld=1&amp;plg_usr=1&amp;plg_vkey=17、http://blog.csdn.net/wusuopubupt/article/details/88178268、https://github.com/LyndonChin/MasteringAndroidDataBinding\\9、https://github.com/googlesamples/android-architecture10、http://www.jianshu.com/p/569ab68da48211、http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0425/4178.html12、http://blog.csdn.net/vector_yi/article/details/24719873","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android Architecture","slug":"Android-Architecture","permalink":"http://yoursite.com/tags/Android-Architecture/"}]},{"title":"Android Architecture（Is Activity God？）","slug":"Android Architecture（Is Activity God？）","date":"2016-05-27T02:12:00.000Z","updated":"2016-05-27T02:12:32.000Z","comments":true,"path":"2016/05/27/Android Architecture（Is Activity God？）/","link":"","permalink":"http://yoursite.com/2016/05/27/Android Architecture（Is Activity God？）/","excerpt":"","text":"分享MVC、MVP、MVVM和Data-Binding的简要PPT","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android Architecture","slug":"Android-Architecture","permalink":"http://yoursite.com/tags/Android-Architecture/"}]},{"title":"DroidPlugin插件化应用分析","slug":"DroidPlugin插件化应用分析","date":"2016-04-25T06:08:00.000Z","updated":"2017-08-04T06:08:56.000Z","comments":true,"path":"2016/04/25/DroidPlugin插件化应用分析/","link":"","permalink":"http://yoursite.com/2016/04/25/DroidPlugin插件化应用分析/","excerpt":"","text":"简介DroidPlugin 是360手机助手在Android系统上实现的一种新的插件机制:它可以在无需安装、修改的情况下运行APK文件,此机制对改进大型APP的架构，实现多团队协作开发具有一定的好处详情请查看DroidPlugin的github地址 背景 将项目中某个相对独立的功能模块分解出来 例如：语音搜索功能模块独立出来，这样减少了项目中依赖包的数量，减少了项目中某些包的层层依赖关系，将语音搜索模块独立成一个单独的apk 可以独立开发语音搜索模块 假设主项目为Host，依赖library为DroidPlugin，独立出来的语音模块生成为voice.apk 应用 这里将独立出来的语音搜索模块打包成单独的apk，放在项目的assets目录下 项目中的设置步骤： 导入DroidPlugin相关的library 在自己的Application当中添加如下代码 123456789101112 @Overridepublic void onCreate() &#123; super.onCreate(); //这里必须在super.onCreate方法之后，顺序不能变 PluginHelper.getInstance().applicationOnCreate(getBaseContext());&#125;@Overrideprotected void attachBaseContext(Context base) &#123; PluginHelper.getInstance().applicationAttachBaseContext(base); super.attachBaseContext(base);&#125; 配置主应用AndroidManifest.xml中相关的组件和权限这里需要注意DroidPlugin library中需要的权限以及组件要在主项目Host中声明还有就是Host中的权限只能比voice的多，不能少，否则会有问题 读取assets里面的voice.apk并复制到sd上或者其他的可读取存储位置，然后再使用DroidPlugin进行安装，这里将需要用到的一些方法封装在PluginUtils工具类中。 当voice.apk通过插件式的形式安装完成以后，我们就可以通过如下方式启动voice.apk 1PluginUtils.startActivity(SearchResultActivity.this,\"com.storm.smart.voice\"); 在Application或者MainActivty中加载voice.apk 12345678910111213141516171819202122232425262728293031323334353637383940/** * 通过DroidPlugin插件安装voice.apk * 从sd卡根目录读取 */ private void droidPluginInstall() &#123; BfExecutor.getInstance().execute(new Runnable() &#123; @Override public void run() &#123; if (PluginUtils.copyApkFromAssets(getApplicationContext(), \"voice.apk\", Environment.getExternalStorageDirectory().getAbsolutePath() + \"/voice.apk\")) &#123; PluginUtils.installApk(getApplicationContext(), Environment.getExternalStorageDirectory().getAbsolutePath() + \"/voice.apk\", \"com.storm.smart.voice\"); &#125; &#125; &#125;); &#125; /** * 通过DroidPlugin插件安装voice.apk * 从data下读取，需要权限（有可能手机没有sd卡） */private void droidPluginInstall() &#123; BfExecutor.getInstance().execute(new Runnable() &#123; @Override public void run() &#123; String path = \"/data/data/\" + getApplicationContext().getPackageName() + \"/files\" + \"/voice.apk\"; try &#123; String command = \"chmod \" + \"666\" + \" \" + path; Runtime runtime = Runtime.getRuntime(); runtime.exec(command); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (PluginUtils.copyApkFromAssets(getApplicationContext(), \"voice.apk\", path)) &#123; PluginUtils.installApk(getApplicationContext(), path, \"com.storm.smart.voice\"); &#125; &#125; &#125;);&#125; PluginUtils全部代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class PluginUtils &#123; public static void startActivity(Activity activity, String packageName)&#123; PackageManager pm = activity.getPackageManager(); Intent intent = pm.getLaunchIntentForPackage(packageName); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); activity.startActivity(intent); &#125; /** * 删除apk * @param activity * @param packageName */ public static void doUninstall( Activity activity, String packageName) &#123; if (!PluginManager.getInstance().isConnected()) &#123; Toast.makeText(activity, \"服务未连接\", Toast.LENGTH_SHORT).show(); &#125; else &#123; try &#123; PluginManager.getInstance().deletePackage(packageName, 0); Toast.makeText(activity, \"删除完成\", Toast.LENGTH_SHORT).show(); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 应该在线程中安装，此方法仅供测试 * @param activity * @param apkPath * @param packageName */ public static boolean installApk(Context context, String apkPath, String packageName) &#123; if (!PluginManager.getInstance().isConnected()) &#123; //installTips(context,\"插件服务正在初始化，请稍后再试。。。\"); return false; &#125; try &#123; if (PluginManager.getInstance().getPackageInfo(packageName, 0) != null) &#123; //installTips(context,\"已经安装了，不能再安装\"); &#125; else &#123; int re = PluginManager.getInstance().installPackage(apkPath, 0); if(re == PluginManager.INSTALL_FAILED_NO_REQUESTEDPERMISSION)&#123; //安装失败，文件请求的权限太多 //installTips(context,\"安装失败，文件请求的权限太多\"); &#125;else&#123; //安装完成 //installTips(context,\"安装完成\"); return true; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return false; &#125; /**安装提示 * @param context * @param tips */ public static void installTips(Context context,String tips)&#123; Looper.prepare();//1、初始化Looper Toast.makeText(context, tips, Toast.LENGTH_SHORT).show(); Looper.loop();//4、启动消息循环 &#125; /** 将assets文件下的apk读取到读取到指定路径 * @param context * @param fileName * @param path * @return */ public static boolean copyApkFromAssets(Context context, String fileName, String path) &#123; boolean copyIsFinish = false; try &#123; InputStream is = context.getAssets().open(fileName); File file = new File(path); file.createNewFile(); FileOutputStream fos = new FileOutputStream(file); byte[] temp = new byte[1024]; int i = 0; while ((i = is.read(temp)) &gt; 0) &#123; fos.write(temp, 0, i); &#125; fos.close(); is.close(); copyIsFinish = true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return copyIsFinish; &#125; &#125; 总结最终我们会发现在/data/data/【host packageName】下有一个Plugin文件夹，文件夹中有个【voice packageName】文件夹，里面有voice的相关数据这样voice.apk就以插件的方式嵌入到我们的主应用中了。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"插件化","slug":"插件化","permalink":"http://yoursite.com/tags/插件化/"}]},{"title":"移动支付（微信、支付宝、银联）集成","slug":"移动支付（微信、支付宝、银联）集成","date":"2016-04-05T06:00:00.000Z","updated":"2017-08-04T06:09:04.000Z","comments":true,"path":"2016/04/05/移动支付（微信、支付宝、银联）集成/","link":"","permalink":"http://yoursite.com/2016/04/05/移动支付（微信、支付宝、银联）集成/","excerpt":"","text":"微信支付Demo一直返回-1先去官网下载demo运行，第一次可以支付成功，以后就一直返回-1如果是以客户端的官网demo进行测试的话，若一直返回-1，可采用如下方式处理： 删除微信缓冲数据按如下步骤：设置-&gt;应用程序管理器-&gt;微信-&gt;清除数据 使用demo里的debug.keystore来测试功能修改步骤：preferences-&gt;android-&gt;build-&gt;custom debug keystore-&gt;browse。 集成之后总是返回-1可能产生问题的地方：包名不一致等其它原因（按照集成申请步骤来，这个应该很少发生）Demo中的订单模拟其实微信支付的大部分工作是需要服务器端进行完成，微信支付的demo中，帮我们模拟了通过服务器生成订单，并返回prepayid的过程，然后demo中会拿着这些微信给我们模拟好的数据去进行支付，每次测试会向”微信测试”支付0.01元。demo中毕竟是模拟的，我们自己的集成一定是实实在在的，不过这里我并不会涉及到太多关于服务器端需要做什么客户端快速集成微信支付的demo比较冗余，我们把支付需要的东西单独摘出来,画箭头的文件可以copy到自己的工程中，根据实际业务或者代码设计进行修改。另外需要注意如下几点： AndroidManifest.xml中package名字和项目包名一样； 将WXPayEntryActivity.java放在package.wxapi/下面 AndroidManifest.xml中添加.wxapi.WXPayEntryActivity（不添加，支付成功后无法跳转到相应的通知Activity界面）； 集成关键步骤从实际开发的角度来看PayActivity中需要添加的三个必备参数1234567891011121314151617/***************************************************************** * 微信支付需要的参数解释： APP_ID，商户号，API密钥*****************************************************************/// APP_IDpublic static final String APP_ID = \"xxxxxxxxxxxxxx\";// 商户号public static final String MCH_ID = \"yyyyyyyyyyyyyy\";// API密钥，在商户平台设置public static final String API_KEY = \"zzzzzzzzzzzzz\";IWXAPI msgApi ;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState);... msgApi = WXAPIFactory.createWXAPI(this.getApplicationContext(), null); ...&#125; 基本流程 点击微信支付-&gt;检测微信是否安装 未安装toast提示 已安装-&gt;根据需要兑换或者支付的产品id去服务器请求创建订单-&gt;创建订单成功-&gt;根据服务器返回的prepayid调用微信客户端进行微信支付-&gt;微信回调（无论成功、失败或者取消）-&gt;返回支付页面-&gt;去服务器校验订单-&gt;成功则根据校验结果进行相应业务跳转，校验异常可以强制用户进入订单列表页面进行再次比对校验（这个过程需要本地保存一下校验异常的订单，不过具体怎么处理校验异常可以自行制定策略） 一般校验订单是发生在微信客户端回调成功之后再去校验，但有一种情况也需要去校验，就是用户不是通过在微信中操作返回支付页面，而是通过home按键返回，这样支付页面就收不到微信的回调结果，即使已经支付成功，所以我们需要在支付页面回到前台的某个控制时机去再次校验一下订单 另外微信支付客户端的回调是在WXPayEntryActivity中完成的，这里可以自己再进一步封装处理 贴一些相关代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 微信支付使用 * @return */ private String genNonceStr() &#123; Random random = new Random(); return MD5.getMessageDigest(String.valueOf(random.nextInt(10000)).getBytes()); &#125; /** * 微信安装检测 * @return */ private boolean checkApkExist() &#123; if (msgApi.isWXAppInstalled()) &#123; return true; &#125; else &#123; return false; &#125; &#125; /** * 微信支付：调用微信支付 * @param prepayId 支付id */ private void weiXinPay(String prepayId) &#123; PayReq req = new PayReq(); req.appId = APP_ID; req.partnerId = MCH_ID; req.prepayId = prepayId; req.packageValue = \"Sign=WXPay\"; req.nonceStr = genNonceStr(); req.timeStamp = String.valueOf(System.currentTimeMillis() / 1000); StringBuilder sb = new StringBuilder(); sb.append(\"appid=\"); sb.append(req.appId); sb.append(\"&amp;noncestr=\"); sb.append(req.nonceStr); sb.append(\"&amp;package=\"); sb.append(req.packageValue); sb.append(\"&amp;partnerid=\"); sb.append(req.partnerId); sb.append(\"&amp;prepayid=\"); sb.append(req.prepayId); sb.append(\"&amp;timestamp=\"); sb.append(req.timeStamp); sb.append(\"&amp;key=\"); sb.append(API_KEY); String appSign = MD5.getMessageDigest(sb.toString().getBytes()).toUpperCase(); req.sign = appSign; msgApi.registerApp(APP_ID); msgApi.sendReq(req); &#125; 支付宝支付集成过程其实支付宝支付的集成更加简单 支付宝支付的demo上来是不能运行的，因为你缺少需要的参数,这里列举的是客户端需要的123456789/***************************************************************** * 支付宝支付需要的参数解释： 商户PID、商户收款账号、商户私钥*****************************************************************/// 商户PIDpublic static final String PARTNER = \"xxxxxxxxxxxxx\";// 商户收款账号public static final String SELLER = \"yyyyyyyyyyy\";// 商户私钥，pkcs8格式public static final String RSA_PRIVATE = \"zzzzzzzzz\"; 配置文件中不要忘记加入：(否则当手机没有安装支付宝客户端时无法调用支付成功)1234567 &lt;!-- alipay sdk begin --&gt; &lt;activityandroid:name=\"com.alipay.sdk.app.H5PayActivity\" android:configChanges=\"orientation|keyboardHidden|navigation|screenSize\"android:exported=\"false\"android:screenOrientation=\"behind\" android:windowSoftInputMode=\"adjustResize|stateHidden\" &gt; &lt;/activity&gt; &lt;!-- alipay sdk end --&gt; 贴一下相关代码，较demo有些许改动: 注意事项需要注意的地方： 私钥一定配置正确，我看有好多小伙伴会在sign(orderInfo)时获得的sign为null,最终导致做URL编码的时候报空指针，我也碰到过，就是服务器那边给的RSA_PRIVATE有问题。公钥客户端用不着 微信支付只需要传递一个prepayid，而支付宝支付需要穿三个参数，一个是订单号，一个是价格，一个是notify_url 支付宝支付创建订单以及订单校验的过程与微信支付类似，因为同在一个地方，要控制好相应的逻辑 注意一下price的单位，分和元不要搞错了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** * call alipay sdk pay. 调用支付宝SDK支付 */public void alipay(String tradeNo, String price, String notify_url) &#123; // 订单 // String orderInfo = getOrderInfo(\"测试的商品\", \"该测试商品的详细描述\", \"0.01\"); String orderInfo = getOrderInfo(tradeNo, title, payInfo, price, notify_url); // 对订单做RSA 签名 String sign = sign(orderInfo); try &#123; // 仅需对sign 做URL编码 sign = URLEncoder.encode(sign, \"UTF-8\"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; // 完整的符合支付宝参数规范的订单信息 final String payInfo = orderInfo + \"&amp;sign=\\\"\" + sign + \"\\\"&amp;\" + getSignType(); Runnable payRunnable = new Runnable() &#123; @Override public void run() &#123; // 构造PayTask 对象 PayTask alipay = new PayTask(PayActivity.this); // 调用支付接口，获取支付结果 String result = alipay.pay(payInfo); Message msg = new Message(); msg.what = SDK_PAY_FLAG; msg.obj = result; mHandler.sendMessage(msg); &#125; &#125;; // 必须异步调用 ThreadPoolUtils.execute(payRunnable);&#125;/** * create the order info. 创建支付宝订单信息 */public String getOrderInfo(String tradeNo, String subject, String body, String price, String notify_url) &#123; // 签约合作者身份ID String orderInfo = \"partner=\" + \"\\\"\" + PARTNER + \"\\\"\"; // 签约卖家支付宝账号 orderInfo += \"&amp;seller_id=\" + \"\\\"\" + SELLER + \"\\\"\"; // 商户网站唯一订单号 orderInfo += \"&amp;out_trade_no=\" + \"\\\"\" + tradeNo + \"\\\"\"; if (!TextUtils.isEmpty(subject)) &#123; // 商品名称 orderInfo += \"&amp;subject=\" + \"\\\"\" + subject + \"\\\"\"; &#125; if (!TextUtils.isEmpty(body)) &#123; // 商品详情 orderInfo += \"&amp;body=\" + \"\\\"\" + body + \"\\\"\"; &#125; // 商品金额 orderInfo += \"&amp;total_fee=\" + \"\\\"\" + (Integer.parseInt(price) / 100f) + \"\\\"\"; // 服务器异步通知页面路径 orderInfo += \"&amp;notify_url=\" + \"\\\"\" + notify_url + \"\\\"\"; // 服务接口名称， 固定值 orderInfo += \"&amp;service=\\\"mobile.securitypay.pay\\\"\"; // 支付类型， 固定值 orderInfo += \"&amp;payment_type=\\\"1\\\"\"; // 参数编码， 固定值 orderInfo += \"&amp;_input_charset=\\\"utf-8\\\"\"; // 设置未付款交易的超时时间 // 默认30分钟，一旦超时，该笔交易就会自动被关闭。 // 取值范围：1m～15d。 // m-分钟，h-小时，d-天，1c-当天（无论交易何时创建，都在0点关闭）。 // 该参数数值不接受小数点，如1.5h，可转换为90m。 orderInfo += \"&amp;it_b_pay=\\\"30m\\\"\"; // extern_token为经过快登授权获取到的alipay_open_id,带上此参数用户将使用授权的账户进行支付 // orderInfo += \"&amp;extern_token=\" + \"\\\"\" + extern_token + \"\\\"\"; // 支付宝处理完请求后，当前页面跳转到商户指定页面的路径，可空 orderInfo += \"&amp;return_url=\\\"m.alipay.com\\\"\"; // 调用银行卡支付，需配置此参数，参与签名， 固定值 （需要签约《无线银行卡快捷支付》才能使用） // orderInfo += \"&amp;paymethod=\\\"expressGateway\\\"\"; return orderInfo;&#125;/** * 支付宝支付使用 sign the order info. 对订单信息进行签名 * * @param content * 待签名订单信息 */public String sign(String content) &#123; return SignUtils.sign(content, RSA_PRIVATE);&#125;/** * 支付宝支付使用 get the sign type we use. 获取签名方式 */public String getSignType() &#123; return \"sign_type=\\\"RSA\\\"\";&#125; 支付宝支付成功的回调(收到的msg.what为SDK_PAY_FLAG)12345678910111213141516171819202122232425262728293031323334353637383940/** * 支付宝支付客户端回调成功 * @param msg * @param theLayout */ private static void aliSdkPaySuc(Message msg, PayActivity theLayout) &#123; PayResult payResult = new PayResult((String) msg.obj); // 支付宝返回此次支付结果及加签，建议对支付宝签名信息拿签约时支付宝提供的公钥做验签 String resultInfo = payResult.getResult(); String resultStatus = payResult.getResultStatus(); // 判断resultStatus 为“9000”则代表支付成功，具体状态码代表含义可参考接口文档 if (TextUtils.equals(resultStatus, \"9000\")) &#123; /*Toast.makeText(theLayout, \"支付成功\", Toast.LENGTH_SHORT).show();*/ theLayout.payCheck(); &#125; else &#123; // 判断resultStatus 为非“9000”则代表可能支付失败 // “8000”代表支付结果因为支付渠道原因或者系统原因还在等待支付结果确认，最终交易是否成功以服务端异步通知为准（小概率状态） if (TextUtils.equals(resultStatus, \"8000\")) &#123; Toast.makeText(theLayout, \"支付结果确认中\", Toast.LENGTH_SHORT).show(); &#125; else if (TextUtils.equals(resultStatus, \"4000\")) &#123; // 其他值就可以判断为支付失败，包括用户主动取消支付，或者系统返回的错误 Toast.makeText(theLayout, \"支付失败\", Toast.LENGTH_SHORT).show(); &#125; else if(TextUtils.equals(resultStatus, \"6001\"))&#123; theLayout.payCount(\"5\",\"\"); Toast.makeText(theLayout, \"支付取消\", Toast.LENGTH_SHORT).show(); &#125;else if(TextUtils.equals(resultStatus, \"6002\"))&#123; Toast.makeText(theLayout, \"网络连接出错\", Toast.LENGTH_SHORT).show(); &#125; &#125; theLayout.clickAliPay = false; &#125; 银联支付银联商家技术服务SDK下载地址 ##小结 关于微信支付和支付宝支付的坑，上面已经介绍很多了，如果还有问题的话，可以参考一下官方的FAQ 集成起来整体感觉支付宝支付要比微信支付容易点 微信支付可以支付虚拟货币，但是支付宝需要走特殊通道开通 银联支付暂时没做，因为商家账户申请的时间好长 移动支付的过程处理需要在逻辑上做到严谨（对各种异常要提前预判），毕竟是跟钱有关的","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"移动支付","slug":"移动支付","permalink":"http://yoursite.com/tags/移动支付/"},{"name":"微信","slug":"微信","permalink":"http://yoursite.com/tags/微信/"},{"name":"支付宝","slug":"支付宝","permalink":"http://yoursite.com/tags/支付宝/"}]},{"title":"图片选取、拍摄、裁剪、上传","slug":"图片选取、拍摄、裁剪、上传","date":"2016-04-05T05:49:00.000Z","updated":"2017-08-04T06:09:19.000Z","comments":true,"path":"2016/04/05/图片选取、拍摄、裁剪、上传/","link":"","permalink":"http://yoursite.com/2016/04/05/图片选取、拍摄、裁剪、上传/","excerpt":"","text":"图片上传效果图展示 图片上传前的准备带圆角的方形图片使用的第三方控件，主要关注如下一些文件 RoundedDrawable RoundedImageView RoundedTransformationBuilder res目录下的anim、color以及values下的attrs 布局文件代码如下：12345678910111213141516171819202122232425262728293031323334&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"xmlns:tools=\"http://schemas.android.com/tools\"xmlns:app=\"http://schemas.android.com/apk/res/com.soulrelay.uploadpic\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\" android:background=\"@color/f5f5f5\"&gt; &lt;com.soulrelay.uploadpic.view.RoundedImageView android:id=\"@+id/imageCover\" android:layout_width=\"100dp\" android:layout_height=\"100dp\" android:layout_marginLeft=\"50dp\" android:layout_centerVertical=\"true\" android:scaleType=\"center\" android:src=\"@drawable/default_cover_img\" app:border_color=\"@color/border\" app:border_width=\"1dip\" app:corner_radius=\"10dp\" app:mutate_background=\"true\" app:oval=\"false\" /&gt; &lt;TextView android:id=\"@+id/add_cover_txt\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerVertical=\"true\" android:layout_marginLeft=\"10dp\" android:layout_toRightOf=\"@id/imageCover\" android:text=\"添加封面\" android:textColor=\"@color/_3e363d\" android:textSize=\"15sp\" /&gt;&lt;/RelativeLayout&gt; 从下而上弹出的PopupWindow关注如下文件： CoverSelelctPopupWindow cover_select_pop_layout.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class CoverSelelctPopupWindow extends PopupWindow &#123; private Button albumBtn, photoGraphBtn,cancelBtn; private View mMenuView; public CoverSelelctPopupWindow(Activity context, OnClickListener itemsOnClick) &#123; super(context); LayoutInflater inflater = (LayoutInflater) context .getSystemService(Context.LAYOUT_INFLATER_SERVICE); mMenuView = inflater.inflate(R.layout.cover_select_pop_layout, null); albumBtn = (Button) mMenuView.findViewById(R.id.btn_album); photoGraphBtn = (Button) mMenuView.findViewById(R.id.btn_photo_graph); //startRecordBtn = (Button) mMenuView.findViewById(R.id.btn_upload_record); cancelBtn = (Button) mMenuView.findViewById(R.id.btn_cancel_join); // 设置按钮监听 albumBtn.setOnClickListener(itemsOnClick); photoGraphBtn.setOnClickListener(itemsOnClick); // 设置SelectPicPopupWindow的View this.setContentView(mMenuView); // 设置SelectPicPopupWindow弹出窗体的宽 this.setWidth(LayoutParams.FILL_PARENT); // 设置SelectPicPopupWindow弹出窗体的高 this.setHeight(LayoutParams.WRAP_CONTENT); // 设置SelectPicPopupWindow弹出窗体可点击 this.setFocusable(true); // 设置SelectPicPopupWindow弹出窗体动画效果 this.setAnimationStyle(R.style.AnimBottom); // 实例化一个ColorDrawable颜色为半透明 ColorDrawable dw = new ColorDrawable(0x00FFFFFF); // 设置SelectPicPopupWindow弹出窗体的背景 this.setBackgroundDrawable(dw); // mMenuView添加OnTouchListener监听判断获取触屏位置如果在选择框外面则销毁弹出框 mMenuView.setOnTouchListener(new OnTouchListener() &#123; public boolean onTouch(View v, MotionEvent event) &#123; int height = mMenuView.findViewById(R.id.pop_layout).getTop(); int y = (int) event.getY(); if (event.getAction() == MotionEvent.ACTION_UP) &#123; if (y &lt; height) &#123; dismiss(); &#125; &#125; return true; &#125; &#125;); cancelBtn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; dismiss(); &#125; &#125;); &#125;&#125; 布局文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center_horizontal\" android:orientation=\"vertical\" &gt; &lt;LinearLayout android:id=\"@+id/pop_layout\" android:layout_width=\"fill_parent\" android:layout_height=\"175dp\" android:background=\"@color/f33e363d\" android:gravity=\"center_horizontal\" android:orientation=\"vertical\" &gt; &lt;Button android:id=\"@+id/btn_album\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"20dip\" android:layout_marginRight=\"20dip\" android:layout_marginTop=\"16dip\" android:textSize=\"14sp\" android:background=\"@drawable/btn_report_selector\" android:text=\"@string/user_info_photo_album\" android:textColor=\"@color/_3e363d\" /&gt; &lt;Button android:id=\"@+id/btn_photo_graph\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"20dip\" android:layout_marginRight=\"20dip\" android:layout_marginTop=\"8dip\" android:textSize=\"14sp\" android:background=\"@drawable/btn_report_selector\" android:text=\"@string/user_info_photo_camera\" android:textColor=\"@color/_3e363d\" /&gt; &lt;Button android:id=\"@+id/btn_cancel_join\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"16dip\" android:layout_marginLeft=\"20dip\" android:layout_marginRight=\"20dip\" android:textSize=\"14sp\" android:background=\"@drawable/btn_report_selector\" android:text=\"@string/join_cancel_txt\" android:textColor=\"@color/_6f6a6f\" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 通过拍照以及相册获取图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120public class MainActivity extends Activity implements android.view.View.OnClickListener &#123; private RoundedImageView imgCover; private TextView addCover; private CoverSelelctPopupWindow coverSelelctPopupWindow; public static final int ACTIVITY_ALBUM_REQUESTCODE = 2000; public static final int ACTIVITY_CAMERA_REQUESTCODE = 2001; public static final int ACTIVITY_MODIFY_PHOTO_REQUESTCODE = 2002; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initViews(); &#125; private void initViews() &#123; imgCover = (RoundedImageView) this.findViewById(R.id.imageCover); addCover = (TextView) this.findViewById(R.id.add_cover_txt); imgCover.setOnClickListener(this); addCover.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.imageCover: case R.id.add_cover_txt: coverSelelctPopupWindow = new CoverSelelctPopupWindow(this, itemsOnClick); coverSelelctPopupWindow.showAtLocation(findViewById(R.id.add_cover_txt), Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL, 0, 0); //设置layout在PopupWindow中显示的位置 break; default: break; &#125; &#125; // 为弹出窗口实现监听类 private OnClickListener itemsOnClick = new OnClickListener() &#123; public void onClick(View v) &#123; coverSelelctPopupWindow.dismiss(); if (CommonUtils.isFastDoubleClick()) &#123; return; &#125; switch (v.getId()) &#123; case R.id.btn_album: Intent i = new Intent(Intent.ACTION_PICK, null);// 调用android的图库 i.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, \"image/*\"); startActivityForResult(i, ACTIVITY_ALBUM_REQUESTCODE); break; case R.id.btn_photo_graph: if (CommonUtils.isExistCamera(MainActivity.this)) &#123; Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);// 调用android自带的照相机 Uri imageUri = Uri.fromFile(FileUtil.getHeadPhotoFileRaw()); intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri); intent.putExtra(MediaStore.Images.Media.ORIENTATION, 0); startActivityForResult(intent, ACTIVITY_CAMERA_REQUESTCODE); &#125; else &#123; Toast.makeText(MainActivity.this, getResources().getString(R.string.user_no_camera), Toast.LENGTH_SHORT).show(); &#125; break; &#125; &#125; &#125;; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); switch (requestCode) &#123; case ACTIVITY_ALBUM_REQUESTCODE: if (resultCode == Activity.RESULT_OK) &#123; if(data.getData() == null)&#123; ToastUtils.toast(this, getString(R.string.pic_not_valid)); return; &#125; CommonUtils.cutPhoto(this, data.getData(), true); &#125; break; case ACTIVITY_CAMERA_REQUESTCODE: if (resultCode == Activity.RESULT_OK) &#123; BitmapFactory.Options bitmapOptions = new BitmapFactory.Options(); bitmapOptions.inSampleSize = 2; int degree = FileUtil.readPictureDegree(FileUtil.getHeadPhotoDir() + FileUtil.HEADPHOTO_NAME_RAW); Bitmap cameraBitmap = BitmapFactory.decodeFile(FileUtil.getHeadPhotoDir() + FileUtil.HEADPHOTO_NAME_RAW, bitmapOptions); cameraBitmap = FileUtil.rotaingImageView(degree, cameraBitmap); FileUtil.saveCutBitmapForCache(this,cameraBitmap); CommonUtils.cutPhoto(this, Uri.fromFile(FileUtil.getHeadPhotoFileRaw()), true); &#125; break; case ACTIVITY_MODIFY_PHOTO_REQUESTCODE:// Bundle bundle = data.getExtras();// if (bundle != null) &#123;// Bitmap bitmap = bundle.getParcelable(\"data\");// if (bitmap == null) &#123;// return;// &#125;// headImg.setImageBitmap(bitmap);// &#125; String coverPath = FileUtil.getHeadPhotoDir() + FileUtil.HEADPHOTO_NAME_TEMP; Bitmap bitmap = BitmapFactory.decodeFile(coverPath); imgCover.setImageBitmap(bitmap); //接下来是完成上传功能 /* HttpUtil.uploadCover(this, UrlContainer.UP_LIVE_COVER + \"?uid=\" + LoginUtils.getInstance(this), coverPath, this);*/ //成功之后删除临时图片 FileUtil.deleteTempAndRaw(); break; &#125; &#125;&#125; 拍照获取图片失败的问题过程中发现，如果拍照获取图片的存储路径与裁切后存储的路径一致的话会出现问题，所以分别设置了两个路径，请参考 FileUtil相关代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175public class FileUtil &#123; private static final String TAG = \"FileUtil\"; // 用户头像保存位置 private final static String HEADPHOTO_PATH = \"/Android/data/com.soulrelay.uploadpic/\"; // 剪切头像时临时保存头像名字，完成或取消时删除 public final static String HEADPHOTO_NAME_TEMP = \"user_photo_temp.jpg\"; //拍照临时存取图片 public final static String HEADPHOTO_NAME_RAW = \"user_photo_raw.jpg\"; // 剪切壁纸图片 private final static String WALLPAPER = \"wallpaper.jpg\"; public static String getCropPath(String path) &#123; String storageState = Environment.getExternalStorageState(); if (Environment.MEDIA_REMOVED.equals(storageState)) &#123; return null; &#125; String dirPath = Environment.getExternalStorageDirectory().getAbsolutePath() + HEADPHOTO_PATH + \"cache\" + File.separator; String s = MD5.Md5Encode(path)+\".jpg\"; return dirPath + s; &#125; /** * 用户头像保存路径 */ public static String getHeadPhotoDir() &#123; String storageState = Environment.getExternalStorageState(); if (Environment.MEDIA_REMOVED.equals(storageState)) &#123; return null; &#125; String path = Environment.getExternalStorageDirectory().getAbsolutePath() + HEADPHOTO_PATH; SDCardUtil.mkdirs(path); return path; &#125; /** * 剪切头像时临时保存头像名字，完成或取消时删除 */ public static File getHeadPhotoFileTemp() &#123; File file = new File(getHeadPhotoDir() + HEADPHOTO_NAME_TEMP); return file; &#125; /** * 剪切头像时临时保存头像名字，完成或取消时删除(用于拍照时存储原始图片) */ public static File getHeadPhotoFileRaw() &#123; File file = new File(getHeadPhotoDir() + HEADPHOTO_NAME_RAW); return file; &#125; /** * 获取剪切壁纸图片 */ public static File getWallPaperFile() &#123; File file = new File(getHeadPhotoDir() + WALLPAPER); return file; &#125; public static void saveCutBitmapForCache(Context context, Bitmap bitmap) &#123; File file = new File(getHeadPhotoDir() + /*File.separator +*/ HEADPHOTO_NAME_RAW); try &#123; FileOutputStream out = new FileOutputStream(file); bitmap.compress(Bitmap.CompressFormat.JPEG, 85, out); out.flush(); out.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 读取图片属性：旋转的角度 * @param path 图片绝对路径 * @return degree旋转的角度 */ public static int readPictureDegree(String path) &#123; int degree = 0; try &#123; ExifInterface exifInterface = new ExifInterface(path); int orientation = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL); switch (orientation) &#123; case ExifInterface.ORIENTATION_ROTATE_90: degree = 90; break; case ExifInterface.ORIENTATION_ROTATE_180: degree = 180; break; case ExifInterface.ORIENTATION_ROTATE_270: degree = 270; break; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return degree; &#125; /** * 旋转图片 * @param angle * @param bitmap * @return Bitmap */ public static Bitmap rotaingImageView(int angle , Bitmap bitmap) &#123; //旋转图片 动作 Matrix matrix = new Matrix();; matrix.postRotate(angle); System.out.println(\"angle2=\" + angle); // 创建新的图片 Bitmap resizedBitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true); return resizedBitmap; &#125; /** * Delete the file/dir from the local disk * */ public static boolean deleteFile(String filePath) &#123; if (TextUtils.isEmpty(filePath)) &#123; return false; &#125; File file = new File(filePath); if (!file.exists()) &#123; Log.w(TAG, \"the file is not exist while delete the file\"); return false; &#125; return deleteDir(file); &#125; /** * Delete the file from the local disk * * @param dir */ private static boolean deleteDir(File dir) &#123; if (dir.isDirectory()) &#123; String[] children = dir.list(); if (children != null) &#123; // 递归删除目录中的子目录下 for (int i = 0; i &lt; children.length; i++) &#123; boolean success = deleteDir(new File(dir, children[i])); if (!success) &#123; return false; &#125; &#125; &#125; &#125; if (!dir.canRead() || !dir.canWrite()) &#123; Log.w(TAG, \"has no permission to can or write while delete the file\"); return false; &#125; // 目录此时为空，可以删除 return dir.delete(); &#125; /** * 删除临时文件（拍照的原始图片以及临时文件） * @param path */ public static void deleteTempAndRaw() &#123; deleteFile(FileUtil.getHeadPhotoDir() + FileUtil.HEADPHOTO_NAME_TEMP); deleteFile(FileUtil.getHeadPhotoDir() + FileUtil.HEADPHOTO_NAME_RAW); &#125;&#125; 拍照获取图片角度不正确的问题1234567891011case ACTIVITY_CAMERA_REQUESTCODE: if (resultCode == Activity.RESULT_OK) &#123; BitmapFactory.Options bitmapOptions = new BitmapFactory.Options(); bitmapOptions.inSampleSize = 2; int degree = FileUtil.readPictureDegree(FileUtil.getHeadPhotoDir() + FileUtil.HEADPHOTO_NAME_RAW); Bitmap cameraBitmap = BitmapFactory.decodeFile(FileUtil.getHeadPhotoDir() + FileUtil.HEADPHOTO_NAME_RAW, bitmapOptions); cameraBitmap = FileUtil.rotaingImageView(degree, cameraBitmap); FileUtil.saveCutBitmapForCache(this,cameraBitmap); CommonUtils.cutPhoto(this, Uri.fromFile(FileUtil.getHeadPhotoFileRaw()), true); &#125; break; 如果不存在图片角度的问题可以直接调用(我测试的时候发现：型号相同，系统版本相同的手机上也有可能存在角度不统一的问题，如果有更好的处理方法，欢迎指教！)1CommonUtils.cutPhoto(this, Uri.fromFile(FileUtil.getHeadPhotoFileRaw()), true); 上传成功之后删除临时文件可以根据服务器接口形式，来进行图片上传，我这边上传的格式是传入两个参数 uid 用户id image 图片二进制数据123456789case ACTIVITY_MODIFY_PHOTO_REQUESTCODE: String coverPath = FileUtil.getHeadPhotoDir() + FileUtil.HEADPHOTO_NAME_TEMP; Bitmap bitmap = BitmapFactory.decodeFile(coverPath); imgCover.setImageBitmap(bitmap); //接下来是完成上传功能 /* HttpUtil.uploadCover(this, UrlContainer.UP_LIVE_COVER + \"?uid=\" + LoginUtils.getInstance(this), coverPath, this);*/ //成功之后删除临时图片 FileUtil.deleteTempAndRaw(); 图片上传以及上传之后的处理大家可以在自己的网络请求中按照如下方式处理，然后根据上传成功和失败的回调做相应的事情123456789101112131415161718192021222324252627282930ublic static void uploadCover(final Context context, final String url, final String path, final UploadLiveCoverListener listener) &#123; ThreadPoolUtils.execute(new Runnable() &#123; @Override public void run() &#123; // 添加密钥 try &#123; HttpClient client = new DefaultHttpClient(); MultipartEntity multipartContent = getEntity(context, new HashMap&lt;String, String&gt;()); FileBody fileBody = new FileBody(new File(path), \"image/jpeg\", \"UTF-8\"); multipartContent.addPart(\"image\", fileBody); String ret = doPost(context, url, multipartContent, client); JSONObject json = new JSONObject(ret); int status = json.getInt(\"status\"); if (status == 0) &#123; JSONObject resultO = json.getJSONObject(\"result\"); String imgUrl = resultO.getString(\"img_url\"); listener.onUploadSuccess(imgUrl); &#125;else &#123; listener.onUploadFail(status); &#125; deleteTempAndRaw(path); &#125; catch (Exception e) &#123; listener.onUploadFail(-1); &#125; &#125; &#125;); &#125; 代码下载源代码地址：选我选我选我","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"view","slug":"view","permalink":"http://yoursite.com/tags/view/"}]},{"title":"RxLoginAndRegister","slug":"RxLoginAndRegister","date":"2016-03-29T11:47:00.000Z","updated":"2016-03-30T04:57:30.000Z","comments":true,"path":"2016/03/29/RxLoginAndRegister/","link":"","permalink":"http://yoursite.com/2016/03/29/RxLoginAndRegister/","excerpt":"","text":"RxLoginAndRegister主要包含客户端和服务端两个部分： 客户端使用RxJava和Retrofit搭配完成基本的登录和注册功能 RxJava：一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库（说到根上，它就是一个实现异步操作的库） Retrofit: 类型安全的网络库，封装了okhttp 登录api一个带有两个参数的post请求12345public interface LoginApi &#123; @FormUrlEncoded @POST(\"/LoginServer/login.php\") Observable&lt;ResultReturn&gt; login(@Field(\"email\") String email, @Field(\"password\") String password);&#125; 注意：具体使用方法请参考详细代码 ，其它相关概念不再赘述。 服务端初衷：就是想自己搭建一个最最基本的服务器！ 功能：完成了一个最基本的登录和注册流程 注意：代码结构相对简单！仅供需要的朋友进行参考 部分代码参考github上的一个demo，一时间找不到那个demo的链接了，同时根据本案例自身需求做了一些调整 相关介绍： 集成安装环境：WampServer 即在window下的apache、php和mysql的服务器软件 集成开发环境：Zend Studio12.5.1 数据传输类型：JSON123456789&#123; \"success\": true, \"msg\": \"Login success\", \"result\": &#123; \"name\": \"ss\", \"email\": \"123@qq.com\", \"contact\": \"123\" &#125;&#125; 修改数据库配置文件123456789&lt;?php/* * All database connection variables */ define(\"DB_HOST\", \"localhost\");define(\"DB_USER\", \"root\");define(\"DB_PASSWORD\", \"\");define(\"DB_NAME\", \"simplelogin\"); 数据库的连接 数据表的创建 相关数据操作api参考db_apis.php 登录参考login.php 注册参考register.php","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://yoursite.com/tags/RxJava/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://yoursite.com/tags/Retrofit/"}]}]}